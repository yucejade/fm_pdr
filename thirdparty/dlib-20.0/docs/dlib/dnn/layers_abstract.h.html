<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - layers_abstract.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>// Copyright (C) 2015  Davis E. King (davis@dlib.net)
</font><font color='#009900'>// License: Boost Software License   See LICENSE.txt for the full license.
</font><font color='#0000FF'>#undef</font> DLIB_DNn_LAYERS_ABSTRACT_H_
<font color='#0000FF'>#ifdef</font> DLIB_DNn_LAYERS_ABSTRACT_H_

<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../cuda/tensor_abstract.h.html'>../cuda/tensor_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='core_abstract.h.html'>core_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../cuda/operation_mode.h.html'>../cuda/operation_mode.h</a>"


<font color='#0000FF'>namespace</font> dlib
<b>{</b>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='SUBNET'></a>SUBNET</b> 
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This object represents a deep neural network.  In particular, it is
                the simplified interface through which layer objects interact with their
                subnetworks.  A layer's two important tasks are to (1) take outputs from its
                subnetwork and forward propagate them through itself and (2) to backwards
                propagate an error gradient through itself and onto its subnetwork.
                The idea of a subnetwork is illustrated in the following diagram:

                  +---------------------------------------------------------+
                  | loss &lt;-- layer1 &lt;-- layer2 &lt;-- ... &lt;-- layern &lt;-- input |
                  +---------------------------------------------------------+
                                      ^                            ^
                                      \__ subnetwork for layer1 __/

                Therefore, by "subnetwork" we mean the part of the network closer to the
                input.

                Note that there is no dlib::SUBNET type.  It is shown here purely to
                document the interface layer objects expect to see when they interact
                with a network.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#009900'>// You aren't allowed to copy subnetworks from inside a layer.
</font>        <b><a name='SUBNET'></a>SUBNET</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>delete</font>;
        SUBNET<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>=</font><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>delete</font>;

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_output'></a>get_output</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the output of this subnetwork.  This is the data that the next
                  layer in the network will take as input.
                - have_same_dimensions(#get_gradient_input(), get_output()) == true
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_gradient_input'></a>get_gradient_input</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the error gradient for this subnetwork.  That is, this is the
                  error gradient that this network will use to update itself.  Therefore,
                  when performing back propagation, layers that sit on top of this
                  subnetwork write their back propagated error gradients into
                  get_gradient_input().  Or to put it another way, during back propagation,
                  layers take the contents of their get_gradient_input() and back propagate
                  it through themselves and store the results into their subnetwork's
                  get_gradient_input().
        !*/</font>

        <font color='#0000FF'>const</font> NEXT_SUBNET<font color='#5555FF'>&amp;</font> <b><a name='subnet'></a>subnet</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the subnetwork of *this network.  With respect to the diagram
                  above, if *this was layer1 then subnet() would return the network that
                  begins with layer2.
        !*/</font>

        NEXT_SUBNET<font color='#5555FF'>&amp;</font> <b><a name='subnet'></a>subnet</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the subnetwork of *this network.  With respect to the diagram
                  above, if *this was layer1 then subnet() would return the network that
                  begins with layer2.
        !*/</font>

        <font color='#0000FF'>const</font> INPUT_LAYER<font color='#5555FF'>&amp;</font> <b><a name='input_layer'></a>input_layer</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the very first layer in *this network.  It's equivalent to calling
                  subnet() recursively until you get to the first layer.  This means it will return
                  the object that is an implementation of the EXAMPLE_INPUT_LAYER interface defined
                  in input_abstract.h
        !*/</font>

        INPUT_LAYER<font color='#5555FF'>&amp;</font> <b><a name='input_layer'></a>input_layer</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the very first layer in *this network.  It's equivalent to calling
                  subnet() recursively until you get to the first layer.  This means it will return
                  the object that is an implementation of the EXAMPLE_INPUT_LAYER interface defined
                  in input_abstract.h
        !*/</font>

        <font color='#0000FF'>const</font> layer_details_type<font color='#5555FF'>&amp;</font> <b><a name='layer_details'></a>layer_details</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the layer_details_type instance that defines the behavior of the
                  layer at the top of this network.  I.e. returns the layer details that
                  defines the behavior of the layer nearest to the network output rather
                  than the input layer.  For computational layers, this is the object
                  implementing the EXAMPLE_COMPUTATIONAL_LAYER_ interface that defines the
                  layer's behavior.
        !*/</font>

        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>int</u></font> <b><a name='sample_expansion_factor'></a>sample_expansion_factor</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - When to_tensor() is invoked on this network's input layer it converts N
                  input objects into M samples, all stored inside a resizable_tensor.  It
                  is always the case that M is some integer multiple of N.
                  sample_expansion_factor() returns the value of this multiplier.  To be
                  very specific, it is always true that M==I*N where I is some integer.
                  This integer I is what is returned by sample_expansion_factor().

                  It should be noted that computational layers likely do not care about the
                  sample expansion factor.  It is only really of concern inside a loss
                  layer where you need to know its value so that tensor samples can be
                  matched against truth objects.  Moreover, in most cases the sample
                  expansion factor is 1.
        !*/</font>

    <b>}</b>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='EXAMPLE_COMPUTATIONAL_LAYER_'></a>EXAMPLE_COMPUTATIONAL_LAYER_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                Each computational layer in a deep neural network can be thought of as a
                function, f(data,parameters), that takes in a data tensor, some parameters,
                and produces an output tensor.  You create an entire deep network by
                composing these functions.  Importantly, you are able to use a wide range
                of different functions to accommodate the task you are trying to
                accomplish.  Therefore, dlib includes a number of common layer types but if
                you want to define your own then you simply implement a class with the same
                interface as EXAMPLE_COMPUTATIONAL_LAYER_.

                Note that there is no dlib::EXAMPLE_COMPUTATIONAL_LAYER_ type.  It is shown
                here purely to document the interface that a layer object must implement.

                The central work of defining a layer is implementing the forward and backward
                methods.  When you do this you have four options:
                    - Implement the forward() and backward() methods according to the
                      specification shown below.  Do not implement forward_inplace() and
                      backward_inplace().
                    - Implement the forward() and backward() methods according to the
                      specification shown below, except exclude the computed_output
                      parameter from backward().  Doing this will allow dlib to make some
                      layers execute in-place and therefore run a little faster and use
                      less memory. Do not implement forward_inplace() and
                      backward_inplace().
                    - Implement the forward_inplace() and backward_inplace() methods
                      according to the specification shown below.  Do not implement
                      forward() and backward().  These in-place methods allow some types of
                      layers to be implemented more efficiently.
                    - Implement the forward_inplace() and backward_inplace() methods
                      according to the specification shown below, except exclude the
                      computed_output parameter from backward_inplace().  Doing this will
                      allow dlib to make some layers execute in-place and therefore run a
                      little faster and use less memory.  Do not implement forward() and
                      backward().


                It should also be noted that layers may define additional layer specific
                fields and the solvers can use these fields as they see fit.  For example,
                some layers define get_learning_rate_multiplier() and
                get_weight_decay_multiplier() methods.  The solvers that come with dlib
                look at these methods, if they exist, and adjust the learning rate or
                weight decay for that layer according to the multiplier.  Therefore, you
                can add these methods to your layer types if you want, or even define new
                fields and new solvers that use those fields in some way.  
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='EXAMPLE_COMPUTATIONAL_LAYER_'></a>EXAMPLE_COMPUTATIONAL_LAYER_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Default constructs this object.  This function is not required to do
                  anything in particular but it must exist, that is, it is required that
                  layer objects be default constructable. 
        !*/</font>

        <b><a name='EXAMPLE_COMPUTATIONAL_LAYER_'></a>EXAMPLE_COMPUTATIONAL_LAYER_</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> EXAMPLE_COMPUTATIONAL_LAYER_<font color='#5555FF'>&amp;</font> item
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - EXAMPLE_COMPUTATIONAL_LAYER_ objects are copy constructable
        !*/</font>

        <b><a name='EXAMPLE_COMPUTATIONAL_LAYER_'></a>EXAMPLE_COMPUTATIONAL_LAYER_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> some_other_layer_type<font color='#5555FF'>&amp;</font> item
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Constructs this object from item.  This form of constructor is optional
                  but it allows you to provide a conversion from one layer type to another.
                  For example, the following code is valid only if my_layer2 can be
                  constructed from my_layer1:
                    relu&lt;fc&lt;my_layer1&lt;fc&lt;input&lt;matrix&lt;float&gt;&gt;&gt;&gt;&gt;&gt; my_dnn1;
                    relu&lt;fc&lt;my_layer2&lt;fc&lt;input&lt;matrix&lt;float&gt;&gt;&gt;&gt;&gt;&gt; my_dnn2(my_dnn1);
                  This kind of pattern is useful if you want to use one type of layer
                  during training but a different type of layer during testing since it
                  allows you to easily convert between related deep neural network types.  

                  Additionally, if you provide a constructor to build a layer from another
                  layer type you should also write your layer's deserialize() routine such
                  that it can read that other layer's serialized data in addition to your
                  own serialized data.  
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
            ensures
                - performs any necessary initial memory allocations and/or sets parameters
                  to their initial values prior to learning.  Therefore, calling setup
                  destroys any previously learned parameters.  Also, typically setup()
                  would look at the dimensions of the outputs of sub and configure the
                  number of parameters in *this accordingly.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, 
            resizable_tensor<font color='#5555FF'>&amp;</font> data_output
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
                - setup() has been called.
            ensures
                - Runs the output of the subnetwork through this layer and stores the
                  results into #data_output.  In particular, forward() can use any of the
                  outputs in sub (e.g. sub.get_output(), sub.subnet().get_output(), etc.)
                  to compute whatever it wants.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#009900'>// this parameter is optional
</font>            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, 
            SUBNET<font color='#5555FF'>&amp;</font> sub, 
            tensor<font color='#5555FF'>&amp;</font> params_grad
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
                - setup() has been called.
                - computed_output is the tensor resulting from calling forward(sub,computed_output).  
                  Moreover, this was the most recent call to forward().  This means that
                  forward() is allowed to cache intermediate results so they can be used
                  during the backward computation.
                - have_same_dimensions(gradient_input, computed_output) == true
                - have_same_dimensions(sub.get_gradient_input(), sub.get_output()) == true
                - have_same_dimensions(params_grad, get_layer_params()) == true
            ensures
                - This function outputs the gradients of this layer with respect to the
                  input data from sub and also with respect to this layer's parameters.
                  These gradients are stored into #sub and #params_grad, respectively. To be
                  precise, the gradients are taken of a function f(sub,get_layer_params())
                  which is defined thusly:   
                    - Recalling that computed_output is a function of both sub and get_layer_params(), 
                      since it is the result of calling forward(sub,computed_output):
                      let f(sub,get_layer_params()) == dot(computed_output, gradient_input)
                  Then we define the following gradient vectors: 
                    - PARAMETER_GRADIENT == gradient of f(sub,get_layer_params()) with
                      respect to get_layer_params(). 
                    - for all valid I:
                        - DATA_GRADIENT_I == gradient of f(sub,get_layer_params()) with
                          respect to layer&lt;I&gt;(sub).get_output() (recall that forward() can
                          draw inputs from the immediate sub layer, sub.subnet(), or
                          any earlier layer.  So you must consider the gradients with
                          respect to all inputs drawn from sub)
                  Finally, backward() outputs these gradients by performing:
                    - params_grad = PARAMETER_GRADIENT 
                    - for all valid I:
                        - layer&lt;I&gt;(sub).get_gradient_input() += DATA_GRADIENT_I
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> data_input, 
            tensor<font color='#5555FF'>&amp;</font> data_output
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - have_same_dimensions(data_input,data_output) == true
                - setup() has been called.
            ensures
                - Runs the data_input tensor through this layer and stores the output into
                  #data_output.
                - This function supports in-place operation, i.e. having
                  is_same_object(data_input, data_output)==true
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#009900'>// this parameter is optional
</font>            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input,
            tensor<font color='#5555FF'>&amp;</font> data_grad,
            tensor<font color='#5555FF'>&amp;</font> params_grad
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - setup() has been called.
                - computed_output is the tensor resulting from the most recent call to
                  forward_inplace().  This means that forward_inplace() is allowed to cache
                  intermediate results so they can be used during the backward computation.
                - have_same_dimensions(gradient_input, data_grad) == true
                - have_same_dimensions(gradient_input, computed_output) == true
                - have_same_dimensions(params_grad, get_layer_params()) == true
            ensures
                - This function supports in-place operation, i.e. having
                  is_same_object(gradient_input, data_grad)==true
                - This function outputs the gradients of this layer with respect to the
                  input data from a sublayer and also with respect to this layer's parameters.
                  These gradients are stored into #data_grad and #params_grad, respectively. To be
                  precise, the gradients are taken of a function f(data_input,get_layer_params())
                  which is defined thusly:   
                    - Recalling that computed_output is a function of both the input to
                      forward_inplace() and get_layer_params(), since it is the result of
                      calling forward_inplace(data_input,computed_output):
                      let f(data_input,get_layer_params()) == dot(computed_output, gradient_input)
                  Then we define the following gradient vectors: 
                    - PARAMETER_GRADIENT == gradient of f(data_input,get_layer_params()) with
                      respect to get_layer_params(). 
                    - DATA_GRADIENT == gradient of f(data_input,get_layer_params()) with respect
                      to data_input. 
                  Finally, backward_inplace() outputs these gradients by performing:
                    - params_grad = PARAMETER_GRADIENT 
                    - if (is_same_object(gradient_input, data_grad)) then
                        - data_grad = DATA_GRADIENT
                    - else
                        - data_grad += DATA_GRADIENT
        !*/</font>

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the parameters that define the behavior of forward().
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the parameters that define the behavior of forward().
        !*/</font>


        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            These two functions are optional.  If provided, they should map between
            (column,row) coordinates in input and output tensors of forward().  Providing
            these functions allows you to use global utility functions like
            input_tensor_to_output_tensor().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='clean'></a>clean</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            Implementing this function is optional.  If you don't need it then you don't
            have to provide a clean().  But if you do provide it then it must behave as
            follows:

            ensures
                - calling clean() causes this object to forget about everything except its
                  parameters.  This is useful if your layer caches information between
                  forward and backward passes and you want to clean out that cache
                  information before saving the network to disk.  
        !*/</font>

    <b>}</b>;

    std::ostream<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>std::ostream<font color='#5555FF'>&amp;</font> out, <font color='#0000FF'>const</font> EXAMPLE_COMPUTATIONAL_LAYER_<font color='#5555FF'>&amp;</font> item<font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        print a string describing this layer.
    !*/</font>

    <font color='#0000FF'><u>void</u></font> <b><a name='to_xml'></a>to_xml</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> EXAMPLE_COMPUTATIONAL_LAYER_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        This function is optional, but required if you want to print your networks with
        net_to_xml().  Therefore, to_xml() prints a layer as XML.
    !*/</font>

    <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> EXAMPLE_COMPUTATIONAL_LAYER_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
    <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>EXAMPLE_COMPUTATIONAL_LAYER_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        provides serialization support  
    !*/</font>

    <font color='#009900'>// For each layer you define, always define an add_layer template so that layers can be
</font>    <font color='#009900'>// easily composed.  Moreover, the convention is that the layer class ends with an _
</font>    <font color='#009900'>// while the add_layer template has the same name but without the trailing _.
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> EXAMPLE_COMPUTATIONAL_LAYER <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>EXAMPLE_COMPUTATIONAL_LAYER_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font><font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>enum</font> <b><a name='fc_bias_mode'></a>fc_bias_mode</b>
    <b>{</b>
        FC_HAS_BIAS <font color='#5555FF'>=</font> <font color='#979000'>0</font>,
        FC_NO_BIAS <font color='#5555FF'>=</font> <font color='#979000'>1</font>
    <b>}</b>;

    <font color='#0000FF'>struct</font> <b><a name='num_fc_outputs'></a>num_fc_outputs</b>
    <b>{</b>
        <b><a name='num_fc_outputs'></a>num_fc_outputs</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> n<font face='Lucida Console'>)</font> : num_outputs<font face='Lucida Console'>(</font>n<font face='Lucida Console'>)</font> <b>{</b><b>}</b>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs;
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs,
        fc_bias_mode bias_mode
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='fc_'></a>fc_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON num_outputs
                num_outputs &gt; 0

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a fully connected layer that
                takes an input tensor and multiplies it by a weight matrix and outputs the
                results.

                The dimensions of the tensors output by this layer are as follows (letting
                IN be the input tensor and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == get_num_outputs()
                    - OUT.nr() == 1
                    - OUT.nc() == 1
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='fc_'></a>fc_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_num_outputs() == num_outputs
                - #get_bias_mode() == bias_mode 
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 1
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 0
        !*/</font>

        <b><a name='fc_'></a>fc_</b><font face='Lucida Console'>(</font>
            num_fc_outputs o
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_num_outputs() == o.num_outputs 
                - #get_bias_mode() == bias_mode 
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 1
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 0
        !*/</font>

        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='get_num_outputs'></a>get_num_outputs</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - This layer outputs column vectors that contain get_num_outputs()
                  elements. That is, the output tensor T from forward() will be such that:
                    - T.num_samples() == however many samples were given to forward().
                    - T.k() == get_num_outputs()
                    - The rest of the dimensions of T will be 1.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_num_outputs'></a>set_num_outputs</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>long</u></font> num
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - num &gt; 0
                - get_layer_params().size() == 0 || get_num_outputs() == num
                  (i.e. You can't change the number of outputs in fc_ if the parameter
                  tensor has already been allocated.)
            ensures
                - #get_num_outputs() == num
        !*/</font>

        fc_bias_mode <b><a name='get_bias_mode'></a>get_bias_mode</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the bias mode which determines if this layer includes bias terms.
                  That is, if the bias mode is FC_HAS_BIAS then a different constant scalar
                  is added to each of the outputs of this layer. 
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;  
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its parameters be
                  multiplied by get_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_weight_decay_multiplier'></a>get_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its parameters be
                  multiplied by get_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_weight_decay_multiplier'></a>set_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_learning_rate_multiplier'></a>get_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its bias parameters be
                  multiplied by get_learning_rate_multiplier()*get_bias_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_weight_decay_multiplier'></a>get_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its bias parameters be
                  multiplied by get_weight_decay_multiplier()*get_bias_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_learning_rate_multiplier'></a>set_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_weight_decay_multiplier'></a>set_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='disable_bias'></a>disable_bias</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - bias_is_disabled() returns true
        !*/</font>

        <font color='#0000FF'><u>bool</u></font> <b><a name='bias_is_disabled'></a>bias_is_disabled</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns true if bias learning is disabled for this layer.  This means the biases will
                  not be learned during the training and they will not be used in the forward or backward
                  methods either.
        !*/</font>

        alias_tensor_const_instance <b><a name='get_weights'></a>get_weights</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns an alias of get_layer_params(), containing the weights matrix of
                  the fully connected layer.
                - #get_weights().num_samples() is the number of elements in input sample,
                  i.e. sublayer's output's k * nc * nr.
                - #get_bias().k() == #get_num_outputs()
                - if get_bias_mode() == FC_HAS_BIAS:
                    - #get_layer_params().size() == (#get_weights().size() + #get_biases().size())
                - else:
                    - #get_layer_params().size() == #get_weights().size()
        !*/</font>

        alias_tensor_instance <b><a name='get_weights'></a>get_weights</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns an alias of get_layer_params(), containing the weights matrix of
                  the fully connected layer.
                - #get_weights().num_samples() is the number of elements in input sample,
                  i.e. sublayer's output's k * nc * nr.
                - #get_bias().k() == #get_num_outputs()
                - if get_bias_mode() == FC_HAS_BIAS:
                    - #get_layer_params().size() == (#get_weights().size() + #get_biases().size())
                - else:
                    - #get_layer_params().size() == #get_weights().size()
        !*/</font>

        alias_tensor_const_instance <b><a name='get_biases'></a>get_biases</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            requires
                - #get_bias_mode() == FC_HAS_BIAS
            ensures
                - returns an alias of get_layer_params(), containing the bias vector of
                  the fully connected layer.
                - #get_bias().num_samples() == 1
                - #get_bias().k() == #get_num_outputs()
                - #get_layer_params().size() == (#get_weights().size() + #get_biases().size())
        !*/</font>

        alias_tensor_instance <b><a name='get_biases'></a>get_biases</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - #get_bias_mode() == FC_HAS_BIAS
            ensures
                - returns an alias of get_layer_params(), containing the bias vector of
                  the fully connected layer.
                - #get_bias().num_samples() == 1
                - #get_bias().k() == #get_num_outputs()
                - #get_layer_params().size() == (#get_weights().size() + #get_biases().size())
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>

    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> fc <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>fc_<font color='#5555FF'>&lt;</font>num_outputs,FC_HAS_BIAS<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> fc_no_bias <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>fc_<font color='#5555FF'>&lt;</font>num_outputs,FC_NO_BIAS<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>enum</font> <b><a name='linear_bias_mode'></a>linear_bias_mode</b>
    <b>{</b>
        LINEAR_HAS_BIAS,
        LINEAR_NO_BIAS
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs,
        linear_bias_mode bias_mode
    <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='linear_'></a>linear_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON num_outputs
                num_outputs &gt; 0

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of a linear layer, which applies a linear
                transformation to the input data. For a layer with bias, the transformation
                is:
                    output = input * weights + bias
                For a layer without bias, it's simply:
                    output = input * weights

                The input tensor can have any number of sample, k (channel), and nr (row)
                dimensions, but the nc (column) dimension must match the number of input features.
                The output tensor will have the same dimensions as the input tensor, except for
                the nc dimension which will be equal to num_outputs.

                This layer is similar to the fc_ layer, but optimized for the case where the
                input and output tensors maintain the same dimensions, excluding the feature
                dimension (nc). This makes it useful for working with multi-dimensional data.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='linear_'></a>linear_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_num_outputs() == num_outputs
                - #get_bias_mode() == bias_mode
                - #get_learning_rate_multiplier() == 1
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier that will be applied to the gradient of this layer during
                  training. This value appears as a multiplicative factor in the update rule. So
                  if get_learning_rate_multiplier() == 1 then the learning rate will be multiplied
                  by 1 and thus not modified. However, if get_learning_rate_multiplier() == 0.1 then
                  the learning rate will be multiplied by 0.1, making the layer update 10 times
                  slower than it would otherwise be.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='get_num_inputs'></a>get_num_inputs</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the number of input features this layer expects.
                - For an uninitialized layer (i.e., one that has not seen any data during setup
                  or forward pass), this will be zero.
        !*/</font>

        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='get_num_outputs'></a>get_num_outputs</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the number of output features this layer produces.
                  I.e., this value is num_outputs.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_num_outputs'></a>set_num_outputs</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>long</u></font> num
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - num &gt; 0
            ensures
                - #get_num_outputs() == num
            throws
                - std::runtime_error if this function is called after the layer parameters
                  have been allocated and the new number of outputs doesn't match the
                  previously set number of outputs.
        !*/</font>

        linear_bias_mode <b><a name='get_bias_mode'></a>get_bias_mode</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns a value indicating whether this layer has a bias term.
                  I.e. returns bias_mode.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Performs the necessary setup work to process data through this layer.
                - Sets the input size based on the dimensions of the input tensor from sub.
                - Allocates the parameter tensor and initializes its values.
                - #get_num_inputs() == the number of columns in sub.get_output() (i.e., nc).
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub,
            resizable_tensor<font color='#5555FF'>&amp;</font> output
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - setup() has been called
                - sub.get_output().nc() == get_num_inputs()
            ensures
                - Applies the linear transformation to the input tensor from sub and stores
                  the results in output.
                - #output.num_samples() == sub.get_output().num_samples()
                - #output.k()           == sub.get_output().k()
                - #output.nr()          == sub.get_output().nr()
                - #output.nc()          == get_num_outputs()
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input,
            SUBNET<font color='#5555FF'>&amp;</font> sub,
            tensor<font color='#5555FF'>&amp;</font> params_grad
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - setup() has been called
                - sub.get_output().nc() == get_num_inputs()
                - gradient_input has the same dimensions as the output of forward()
            ensures
                - Computes the gradients of this layer with respect to the parameters
                  and the input tensor, and updates the corresponding gradient tensors.
                - Updates params_grad based on the gradients of the weights
                  and biases (if present).
                - Updates sub's gradient_input based on the gradients of the
                  inputs to this layer.
        !*/</font>

        alias_tensor_instance <b><a name='get_weights'></a>get_weights</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - setup() has been called
            ensures
                - Returns a reference to the weights matrix of this layer.
        !*/</font>

        alias_tensor_const_instance <b><a name='get_weights'></a>get_weights</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            requires
                - setup() has been called
            ensures
                - Returns a const reference to the weights matrix of this layer.
        !*/</font>

        alias_tensor_instance <b><a name='get_biases'></a>get_biases</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - bias_mode == LINEAR_HAS_BIAS
                - setup() has been called
            ensures
                - Returns a reference to the bias vector of this layer.
            throws
                - static_assert failure if bias_mode != LINEAR_HAS_BIAS
        !*/</font>

        alias_tensor_const_instance <b><a name='get_biases'></a>get_biases</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            requires
                - bias_mode == LINEAR_HAS_BIAS
                - setup() has been called
            ensures
                - Returns a const reference to the bias vector of this layer.
            throws
                - static_assert failure if bias_mode != LINEAR_HAS_BIAS
        !*/</font>

        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> dpoint<font color='#5555FF'>&amp;</font> p
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns p, since the linear layer maintains the same spatial dimensions.
        !*/</font>

        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> dpoint<font color='#5555FF'>&amp;</font> p
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns p, since the linear layer maintains the same spatial dimensions.
        !*/</font>

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the parameters that define this layer, i.e., the weights and biases
                  (if present) that are updated during training.
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the parameters that define this layer, i.e., the weights and biases
                  (if present) that are updated during training.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> linear_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>linear_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            provides serialization support
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs,
        <font color='#0000FF'>typename</font> SUBNET
    <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> linear <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>linear_<font color='#5555FF'>&lt;</font>num_outputs, LINEAR_HAS_BIAS<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#009900'>/*!
        This is a layer that applies a linear transformation with bias to the input:
        output = input * weights + bias
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs,
        <font color='#0000FF'>typename</font> SUBNET
    <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> linear_no_bias <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>linear_<font color='#5555FF'>&lt;</font>num_outputs, LINEAR_NO_BIAS<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#009900'>/*!
        This is a layer that applies a linear transformation without bias to the input:
        output = input * weights
    !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>struct</font> <b><a name='num_con_outputs'></a>num_con_outputs</b>
    <b>{</b>
        <b><a name='num_con_outputs'></a>num_con_outputs</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> n<font face='Lucida Console'>)</font> : num_outputs<font face='Lucida Console'>(</font>n<font face='Lucida Console'>)</font> <b>{</b><b>}</b>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_outputs;
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> _num_filters,
        <font color='#0000FF'><u>long</u></font> _nr,
        <font color='#0000FF'><u>long</u></font> _nc,
        <font color='#0000FF'><u>int</u></font> _stride_y,
        <font color='#0000FF'><u>int</u></font> _stride_x,
        <font color='#0000FF'><u>int</u></font> _padding_y <font color='#5555FF'>=</font> _stride_y<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nr<font color='#5555FF'>/</font><font color='#979000'>2</font>,
        <font color='#0000FF'><u>int</u></font> _padding_x <font color='#5555FF'>=</font> _stride_x<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nc<font color='#5555FF'>/</font><font color='#979000'>2</font>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='con_'></a>con_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - _num_filters &gt; 0
                - _nr &gt;= 0
                - _nc &gt;= 0
                - _stride_y &gt; 0
                - _stride_x &gt; 0
                - _padding_y &gt;= 0
                - _padding_x &gt;= 0
                - Also, we require that:
                    - if (_nr == 0) then
                        - _padding_y == 0
                    - else
                        - _padding_y &lt; _nr
                    - if (_nc == 0) then
                        - _padding_x == 0
                    - else
                        - _padding_x &lt; _nc

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a convolution layer that takes an
                input tensor (nominally representing an image) and convolves it with a set
                of filters and then outputs the results. 

                The dimensions of the tensors output by this layer are as follows (letting
                IN be the input tensor and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == num_filters()
                    - OUT.nr() == 1+(IN.nr() + 2*padding_y() - nr())/stride_y()
                    - OUT.nc() == 1+(IN.nc() + 2*padding_x() - nc())/stride_x()

                Note also that setting _nr or _nc to 0 has a special meaning of "set the
                filter size equal to the input image size".  Specifically, it means: 
                    - if (_nr == 0) then
                        - nr() == IN.nr()
                        - OUT.nr() == 1
                    - if (_nc == 0) then
                        - nc() == IN.nc()
                        - OUT.nc() == 1
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='con_'></a>con_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #num_filters() == _num_filters
                - #nr() == _nr
                - #nc() == _nc
                - #stride_y() == _stride_y
                - #stride_x() == _stride_x
                - #padding_y() == _padding_y
                - #padding_x() == _padding_x
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 1
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 0
        !*/</font>

        <b><a name='con_'></a>con_</b><font face='Lucida Console'>(</font>
            num_con_outputs o
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #num_filters() == o.num_outputs 
                - #nr() == _nr
                - #nc() == _nc
                - #stride_y() == _stride_y
                - #stride_x() == _stride_x
                - #padding_y() == _padding_y
                - #padding_x() == _padding_x
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 1
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 0
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='num_filters'></a>num_filters</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of filters contained in this layer.  The k dimension
                  of the output tensors produced by this layer will be equal to the number
                  of filters.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_num_filters'></a>set_num_filters</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>long</u></font> num
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - num &gt; 0
                - get_layer_params().size() == 0 || num_filters() == num
                  (i.e. You can't change the number of filters in con_ if the parameter
                  tensor has already been allocated.)
            ensures
                - #num_filters() == num
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nr'></a>nr</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of rows in the filters in this layer.  Note that if
                  nr()==0 then it means the size of the filter is not yet assigned, but
                  once setup() is called nr() will be set to the input tensor's nr().
                  Therefore, nr()==0 has the special interpretation of "be the same size as
                  the input tensor".
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nc'></a>nc</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the number of columns in the filters in this layer.  Note that if
                  nc()==0 then it means the size of the filter is not yet assigned, but
                  once setup() is called nc() will be set to the input tensor's nc().
                  Therefore, nc()==0 has the special interpretation of "be the same size as
                  the input tensor".
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_y'></a>stride_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the vertical stride used when convolving the filters over an
                  image.  That is, each filter will be moved stride_y() pixels down at a
                  time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_x'></a>stride_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the horizontal stride used when convolving the filters over an
                  image.  That is, each filter will be moved stride_x() pixels right at a
                  time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_y'></a>padding_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the top and bottom
                  sides of the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_x'></a>padding_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the left and right 
                  sides of the image.
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;  
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its parameters be
                  multiplied by get_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_weight_decay_multiplier'></a>get_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its parameters be
                  multiplied by get_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_weight_decay_multiplier'></a>set_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_learning_rate_multiplier'></a>get_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its bias parameters be
                  multiplied by get_learning_rate_multiplier()*get_bias_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_weight_decay_multiplier'></a>get_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its bias parameters be
                  multiplied by get_weight_decay_multiplier()*get_bias_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_learning_rate_multiplier'></a>set_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_weight_decay_multiplier'></a>set_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='disable_relu'></a>disable_relu</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - relu_is_disabled() returns true
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='enable_relu'></a>enable_relu</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - relu_is_disabled() returns false
        !*/</font>

        <font color='#0000FF'><u>bool</u></font> <b><a name='relu_is_disabled'></a>relu_is_disabled</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns true if relu is disabled for this layer. This means no activation function
                  will be applied after the convolution when calling forward.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='disable_bias'></a>disable_bias</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - bias_is_disabled() returns true
                - if bias was enabled and allocated, it resizes the layer parameters
                  to accommodate the filter parameters only, and free the bias parameters.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='enable_bias'></a>enable_bias</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - bias_is_disabled() returns false
                - if bias was disabled and not allocated, it resizes the layer parameters
                  to accommodate the new zero-inizialized biases
        !*/</font>

        <font color='#0000FF'><u>bool</u></font> <b><a name='bias_is_disabled'></a>bias_is_disabled</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns true if bias learning is disabled for this layer.  This means the biases will
                  not be learned during the training and they will not be used in the forward or backward
                  methods either.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>

    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> num_filters,
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'><u>int</u></font> stride_y,
        <font color='#0000FF'><u>int</u></font> stride_x,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> con <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>con_<font color='#5555FF'>&lt;</font>num_filters,nr,nc,stride_y,stride_x<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> _num_filters,
        <font color='#0000FF'><u>long</u></font> _nr,
        <font color='#0000FF'><u>long</u></font> _nc,
        <font color='#0000FF'><u>int</u></font> _stride_y,
        <font color='#0000FF'><u>int</u></font> _stride_x,
        <font color='#0000FF'><u>int</u></font> _padding_y <font color='#5555FF'>=</font> _stride_y<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nr<font color='#5555FF'>/</font><font color='#979000'>2</font>,
        <font color='#0000FF'><u>int</u></font> _padding_x <font color='#5555FF'>=</font> _stride_x<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nc<font color='#5555FF'>/</font><font color='#979000'>2</font>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='cont_'></a>cont_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                All of them must be &gt; 0.
                Also, we require that:
                    - 0 &lt;= _padding_y &amp;&amp; _padding_y &lt; _nr
                    - 0 &lt;= _padding_x &amp;&amp; _padding_x &lt; _nc

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a transposed convolution layer
                that takes an input tensor and transpose convolves (sometimes called
                "deconvolution") it with a set of filters and then outputs the results. 

                This is essentially a convolutional layer that allows fractional strides.
                Therefore, you can make output tensors that are larger than the input
                tensors using this layer type. 

                
                The dimensions of the tensors output by this layer are as follows (letting
                IN be the input tensor and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == num_filters()
                    - OUT.nr() == stride_y()*(IN.nr()-1) + nr() - 2*padding_y()
                    - OUT.nc() == stride_x()*(IN.nc()-1) + nc() - 2*padding_x()
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='cont_'></a>cont_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #num_filters() == _num_filters
                - #nr() == _nr
                - #nc() == _nc
                - #stride_y() == _stride_y
                - #stride_x() == _stride_x
                - #padding_y() == _padding_y
                - #padding_x() == _padding_x
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 1
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 0
        !*/</font>

        <b><a name='cont_'></a>cont_</b><font face='Lucida Console'>(</font>
            num_con_outputs o
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #num_filters() == o.num_outputs 
                - #nr() == _nr
                - #nc() == _nc
                - #stride_y() == _stride_y
                - #stride_x() == _stride_x
                - #padding_y() == _padding_y
                - #padding_x() == _padding_x
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 1
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 0
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='num_filters'></a>num_filters</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of filters contained in this layer.  The k dimension
                  of the output tensors produced by this layer will be equal to the number
                  of filters.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_num_filters'></a>set_num_filters</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>long</u></font> num
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - num &gt; 0
                - get_layer_params().size() == 0 || num_filters() == num
                  (i.e. You can't change the number of filters in cont_ if the parameter
                  tensor has already been allocated.)
            ensures
                - #num_filters() == num
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nr'></a>nr</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of rows in the filters in this layer.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nc'></a>nc</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the number of columns in the filters in this layer.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_y'></a>stride_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the vertical stride used when convolving the filters over an
                  image.  That is, each filter will be moved 1.0/stride_y() pixels down at
                  a time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_x'></a>stride_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the horizontal stride used when convolving the filters over an
                  image.  That is, each filter will be moved 1.0/stride_x() pixels right at
                  a time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_y'></a>padding_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the top and bottom
                  sides of the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_x'></a>padding_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the left and right 
                  sides of the image.
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;  
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its parameters be
                  multiplied by get_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_weight_decay_multiplier'></a>get_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its parameters be
                  multiplied by get_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_weight_decay_multiplier'></a>set_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_learning_rate_multiplier'></a>get_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its bias parameters be
                  multiplied by get_learning_rate_multiplier()*get_bias_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_weight_decay_multiplier'></a>get_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its bias parameters be
                  multiplied by get_weight_decay_multiplier()*get_bias_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_learning_rate_multiplier'></a>set_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_weight_decay_multiplier'></a>set_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='disable_bias'></a>disable_bias</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - bias_is_disabled() returns true
        !*/</font>

        <font color='#0000FF'><u>bool</u></font> <b><a name='bias_is_disabled'></a>bias_is_disabled</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns true if bias learning is disabled for this layer.  This means the biases will
                  not be learned during the training and they will not be used in the forward or backward
                  methods either.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>

    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> num_filters,
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'><u>int</u></font> stride_y,
        <font color='#0000FF'><u>int</u></font> stride_x,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> cont <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>cont_<font color='#5555FF'>&lt;</font>num_filters,nr,nc,stride_y,stride_x<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>int</u></font> scale_y, 
        <font color='#0000FF'><u>int</u></font> scale_x 
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='upsample_'></a>upsample_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                All of them must be &gt;= 1.

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it allows you to upsample a layer using
                bilinear interpolation.  To be very specific, it upsamples each of the
                channels in an input tensor.  Therefore, if IN is the input tensor to this
                layer and OUT the output tensor, then we will have:
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == IN.k() 
                    - OUT.nr() == IN.nr()*scale_y
                    - OUT.nc() == IN.nc()*scale_x
                    - for all valid i,k:  image_plane(OUT,i,k) is a copy of
                      image_plane(IN,i,k) that has been bilinearly interpolated to fit into
                      the shape of image_plane(OUT,i,k).
        !*/</font>
    <font color='#0000FF'>public</font>:

        <b><a name='upsample_'></a>upsample_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - This object has no state, so the constructor does nothing, aside from
                  providing default constructability.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>int</u></font> scale,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> upsample <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>upsample_<font color='#5555FF'>&lt;</font>scale,scale<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> NR_, 
        <font color='#0000FF'><u>long</u></font> NC_
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='resize_to_'></a>resize_to_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON THE INPUT ARGUMENTS
                - NR_ &gt;= 1
                - NC_ &gt;= 1

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it allows you to resize a layer using
                bilinear interpolation.  To be very specific, it resizes each of the
                channels in an input tensor.  Therefore, if IN is the input tensor to this
                layer and OUT the output tensor, then we will have:
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == IN.k() 
                    - OUT.nr() == NR_
                    - OUT.nc() == NC_
                    - for all valid i,k:  image_plane(OUT,i,k) is a copy of
                      image_plane(IN,i,k) that has been bilinearly interpolated to fit into
                      the shape of image_plane(OUT,i,k).
        !*/</font>
    <font color='#0000FF'>public</font>:

        <b><a name='resize_to_'></a>resize_to_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - This object has no state, so the constructor does nothing, aside from
                  providing default constructability.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> NR,
        <font color='#0000FF'><u>long</u></font> NC,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> resize_to <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>resize_to_<font color='#5555FF'>&lt;</font>NR,NC<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>long</u></font> k_ <font color='#5555FF'>=</font> <font color='#5555FF'>-</font><font color='#979000'>1</font>, <font color='#0000FF'><u>long</u></font> nr_ <font color='#5555FF'>=</font> <font color='#5555FF'>-</font><font color='#979000'>1</font>, <font color='#0000FF'><u>long</u></font> nc_ <font color='#5555FF'>=</font> <font color='#5555FF'>-</font><font color='#979000'>1</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='reshape_to_'></a>reshape_to_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - k_, nr_, and nc_ must be either -1 or greater than 0.

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above. It defines a layer that reshapes or resizes an input tensor
                into a different shape. The layer operates in two modes:

                1. Pure Reshape Mode: When the total number of elements in the input tensor
                   equals the total number of elements in the output tensor, this layer
                   performs a simple reshaping operation without changing the values.

                2. Spatial Rescaling Mode: When the channel dimension (k) remains constant
                   but the total number of elements changes, this layer performs bilinear
                   interpolation to resize the spatial dimensions while preserving the
                   channel information.

                The dimensions of the output tensor are determined by the template parameters:
                    - If k_ is -1, the output tensor will have the same number of channels as the input.
                    - If nr_ is -1, the output tensor will have the same number of rows as the input.
                    - If nc_ is -1, the output tensor will have the same number of columns as the input.

                Setting a value of -1 for any dimension means "keep the original dimension from the input."

                Note that this layer will throw an exception if you attempt to change both the
                channel count (k) and the total number of elements. Either:
                - Keep the total number of elements the same (Pure Reshape Mode), or
                - Keep the channel count the same and only change spatial dimensions (Spatial Rescaling Mode)
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#0000FF'>explicit</font> <b><a name='reshape_to_'></a>reshape_to_</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_output_k() == k_
                - #get_output_nr() == nr_
                - #get_output_nc() == nc_
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='get_output_k'></a>get_output_k</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the number of channels in the output tensor. If this value is -1,
                  then the output will have the same number of channels as the input.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='get_output_nr'></a>get_output_nr</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the number of rows in the output tensor. If this value is -1,
                  then the output will have the same number of rows as the input.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='get_output_nc'></a>get_output_nc</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the number of columns in the output tensor. If this value is -1,
                  then the output will have the same number of columns as the input.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_output_k'></a>set_output_k</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>long</u></font> k<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - k == -1 || k &gt; 0
            ensures
                - #get_output_k() == k
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_output_nr'></a>set_output_nr</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>long</u></font> nr<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - nr == -1 || nr &gt; 0
            ensures
                - #get_output_nr() == nr
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_output_nc'></a>set_output_nc</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>long</u></font> nc<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - nc == -1 || nc &gt; 0
            ensures
                - #get_output_nc() == nc
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
            ensures
                - Configures this layer to operate on the output of sub.
                - If the total number of elements in the input tensor doesn't match the total
                  number of elements in the output tensor and the channel dimension is different,
                  an exception will be thrown.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
                - setup() has been called.
            ensures
                - Reshapes or resizes the output of sub and stores it in #output.
                - If is_spatial_rescale() == false, then performs a pure reshape operation.
                - If is_spatial_rescale() == true, then performs bilinear interpolation to resize
                  the spatial dimensions while preserving the channel information.
                - #output.num_samples() == sub.get_output().num_samples()
                - #output.k() == get_output_k() if get_output_k() != -1, otherwise sub.get_output().k()
                - #output.nr() == get_output_nr() if get_output_nr() != -1, otherwise sub.get_output().nr()
                - #output.nc() == get_output_nc() if get_output_nc() != -1, otherwise sub.get_output().nc()
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input,
            SUBNET<font color='#5555FF'>&amp;</font> sub,
            tensor<font color='#5555FF'>&amp;</font> params_grad
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
                - setup() has been called.
                - gradient_input has the same dimensions as the output of forward().
            ensures
                - Computes the gradients of this layer with respect to the input tensor and
                  parameters, and stores them in sub.get_gradient_input() and params_grad,
                  respectively.
                - This function supports both pure reshaping and spatial rescaling operations.
        !*/</font>

        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Maps a point in the input tensor's coordinate system to the corresponding point
                  in the output tensor. This is useful for tracking how spatial locations change
                  through the network, especially during spatial rescaling.
        !*/</font>

        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Maps a point in the output tensor's coordinate system to the corresponding point
                  in the input tensor. This is the inverse of map_input_to_output().
        !*/</font>

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the layer's parameters. This layer has no parameters,
                  so this always returns an empty tensor.
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the layer's parameters. This layer has no parameters,
                  so this always returns an empty tensor.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>long</u></font> k, <font color='#0000FF'><u>long</u></font> nr, <font color='#0000FF'><u>long</u></font> nc, <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> reshape_to <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>reshape_to_<font color='#5555FF'>&lt;</font>k, nr, nc<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>long</u></font> k, <font color='#0000FF'><u>long</u></font> nr, <font color='#0000FF'><u>long</u></font> nc, <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> flatten <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>reshape_to_<font color='#5555FF'>&lt;</font>k <font color='#5555FF'>*</font> nr, <font color='#5555FF'>*</font> nc, <font color='#979000'>1</font>, <font color='#979000'>1</font><font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='dropout_'></a>dropout_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a dropout layer.  Therefore, it
                passes its inputs through the stochastic function f(x) which outputs either
                0 or x.  The probability of 0 being output is given by the drop_rate
                argument to this object's constructor.

                Note that, after you finish training a network with dropout, it is a good
                idea to replace each dropout_ layer with a multiply_ layer because the
                multiply_ layer is faster and deterministic. 
        !*/</font>

    <font color='#0000FF'>public</font>:

        <font color='#0000FF'>explicit</font> <b><a name='dropout_'></a>dropout_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> drop_rate <font color='#5555FF'>=</font> <font color='#979000'>0.5</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - 0 &lt;= drop_rate &lt;= 1
            ensures
                - #get_drop_rate() == drop_rate
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_drop_rate'></a>get_drop_rate</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the probability that an individual input value to this layer will
                  be replaced with 0.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> dropout <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>dropout_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>int</u></font> DROP_RATE_PERCENT<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='dropout_rate_'></a>dropout_rate_</b> : <font color='#0000FF'>public</font> dropout_
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This object represents a customizable dropout layer that inherits from
                the dropout_ class. It allows specifying the dropout rate at compile-time,
                which is particularly useful for deep networks with many layers where it
                might be cumbersome to explicitly modify the dropout rate for each layer
                individually.

                The main advantage of this layer is that it offers the possibility to specify
                the dropout rate at the moment of network construction, providing more
                flexibility and clarity in the network architecture definition.

            TEMPLATE PARAMETERS
                - DROP_RATE_PERCENT: A int value between 0 and 100 that specifies the dropout rate.
                  This value is set at compile-time and cannot be changed during runtime.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#0000FF'>explicit</font> <b><a name='dropout_rate_'></a>dropout_rate_</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Constructs a dropout layer with a dropout rate of DROP_RATE.
                - Calls the base class constructor dropout_(DROP_RATE).
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>int</u></font> DROP_RATE, <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> dropout_rate <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>dropout_rate_<font color='#5555FF'>&lt;</font>DROP_RATE<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> dropout_10 <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>dropout_rate_<font color='#5555FF'>&lt;</font><font color='#979000'>10</font><font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='multiply_'></a>multiply_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a basic layer that just
                multiplies its input tensor with a constant value and returns the result.
                It therefore has no learnable parameters.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#0000FF'>explicit</font> <b><a name='multiply_'></a>multiply_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> val <font color='#5555FF'>=</font> <font color='#979000'>0.5</font>
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            ensures
                - #get_multiply_value() == val
        !*/</font>

        <b><a name='multiply_'></a>multiply_</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> dropout_<font color='#5555FF'>&amp;</font> item
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            ensures
                - #get_multiply_value() == 1-item.get_drop_rate()
                  (i.e. We construct the multiply_ layer so that it is essentially a
                  deterministic version of the given dropout_ layer)
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_multiply_value'></a>get_multiply_value</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - this layer simply multiplies its input tensor by get_multiply_value() and
                  produces the result as output.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> multiply <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>multiply_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> <font color='#0000FF'><u>double</u></font> DEFAULT_LAYER_NORM_EPS <font color='#5555FF'>=</font> <font color='#979000'>1e</font><font color='#5555FF'>-</font><font color='#979000'>5</font>;

    <font color='#0000FF'>class</font> <b><a name='layer_norm_'></a>layer_norm_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a batch normalization layer that
                implements the method described in the paper:
                    Layer Normalization by Jimmy Lei Ba, Jamie Ryan Kiros, Geoffrey E. Hinton

                In particular, this layer produces output tensors with the same
                dimensionality as the input tensors, except that the mean and variances of
                the elements in each sample have been standardized to 0 and 1 respectively.
                This is different from batch normalization, since this layer learns one scaling
                factor and one bias for each sample in the batch, independently.  As a result,
                this layer is batch-size independent.
        !*/</font>
    <font color='#0000FF'>public</font>:
        <b><a name='layer_norm_'></a>layer_norm_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_learning_rate_multiplier()       == 1
                - #get_weight_decay_multiplier()        == 0
                - #get_bias_learning_rate_multiplier()  == 1
                - #get_bias_weight_decay_multiplier()   == 1
                - #get_eps() == DEFAULT_LAYER_NORM_EPS
        !*/</font>

        <font color='#0000FF'>explicit</font> <b><a name='layer_norm_'></a>layer_norm_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> eps_ <font color='#5555FF'>=</font> DEFAULT_LAYER_NORM_EPS
        <font face='Lucida Console'>)</font>
        <font color='#009900'>/*!
            requires
                - eps &gt; 0
            ensures
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 0
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 1
                - #get_eps() == eps
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_eps'></a>get_eps</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - When doing layer normalization, we are dividing by the standard
                  deviation.  This epsilon value returned by this function is added to the
                  variance to prevent the division from dividing by zero.
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its parameters be
                  multiplied by get_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_weight_decay_multiplier'></a>get_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its parameters be
                  multiplied by get_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_weight_decay_multiplier'></a>set_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_learning_rate_multiplier'></a>get_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its bias parameters be
                  multiplied by get_learning_rate_multiplier()*get_bias_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_weight_decay_multiplier'></a>get_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its bias parameters be
                  multiplied by get_weight_decay_multiplier()*get_bias_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_learning_rate_multiplier'></a>set_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_weight_decay_multiplier'></a>set_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> <font color='#0000FF'><u>float</u></font> DEFAULT_RMS_NORM_EPS <font color='#5555FF'>=</font> <font color='#979000'>1e</font><font color='#5555FF'>-</font><font color='#979000'>5</font>f;

    <font color='#0000FF'>class</font> <b><a name='rms_norm_'></a>rms_norm_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This object implements the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above, specifically defining a root mean square (RMS) normalization layer.

                RMS normalization is a technique that normalizes the input tensor based on the
                root mean square (RMS) of its elements. Unlike traditional layer normalization,
                which both centers and scales the data, RMS normalization only scales by the RMS
                value. This makes it computationally more efficient, as it avoids the need to
                compute the mean and subtract it from each element.

                This layer produces output tensors with the same dimensionality as the input tensors.
                Specifically, for an input tensor with shape [num_samples, k, nr, nc], the RMS
                normalization is applied across the [nr, nc] dimensions independently for each
                element in the [k] dimension and for each sample in the [num_samples] dimension.
                The scaling factor (RMS) and the learnable scaling parameter (gamma) are both of
                size [k].

                The key characteristics of this layer are:
                - The RMS of the elements in each sample is standardized to 1.
                - It does not center the data (i.e., it does not subtract the mean).
                - A learnable scaling factor (gamma) is applied after normalization, allowing the
                model to adapt the scaling dynamically.

                This layer is particularly effective in various natural language processing tasks,
                where it has been shown to provide performance similar to or better than traditional
                layer normalization, with reduced computational overhead.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='rms_norm_'></a>rms_norm_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_learning_rate_multiplier() == 1
                - #get_weight_decay_multiplier()  == 0
                - #get_bias_learning_rate_multiplier()  == 1
                - #get_bias_weight_decay_multiplier()   == 1            
                - #get_eps() == DEFAULT_RMS_NORM_EPS
        !*/</font>

        <font color='#0000FF'>explicit</font> <b><a name='rms_norm_'></a>rms_norm_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> eps_ <font color='#5555FF'>=</font> DEFAULT_RMS_NORM_EPS
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - eps &gt; 0
            ensures
                - #get_learning_rate_multiplier() == 1
                - #get_weight_decay_multiplier()  == 0
                - #get_bias_learning_rate_multiplier()  == 1
                - #get_bias_weight_decay_multiplier()   == 1            
                - #get_eps() == eps_
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_eps'></a>get_eps</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - When doing RMS normalization, we are dividing by the root mean square.
                This epsilon value returned by this function is added to the
                mean square to prevent division by zero.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_eps'></a>set_eps</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt; 0
            ensures
                - #get_eps() == val
        !*/</font>    

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number. The interpretation is that this object is
                requesting that the learning rate used to optimize its parameters be
                multiplied by get_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_weight_decay_multiplier'></a>get_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number. The interpretation is that this object is
                requesting that the weight decay used to optimize its parameters be
                multiplied by get_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_weight_decay_multiplier'></a>set_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_learning_rate_multiplier'></a>get_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                requesting that the learning rate used to optimize its bias parameters be
                multiplied by get_learning_rate_multiplier()*get_bias_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_weight_decay_multiplier'></a>get_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                requesting that the weight decay used to optimize its bias parameters be
                multiplied by get_weight_decay_multiplier()*get_bias_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_learning_rate_multiplier'></a>set_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_weight_decay_multiplier'></a>set_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> rms_norm <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>rms_norm_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>enum</font> <b><a name='layer_mode'></a>layer_mode</b>
    <b>{</b>
        CONV_MODE <font color='#5555FF'>=</font> <font color='#979000'>0</font>, <font color='#009900'>// convolutional mode
</font>        FC_MODE <font color='#5555FF'>=</font> <font color='#979000'>1</font>    <font color='#009900'>// fully connected mode
</font>    <b>}</b>;

    <font color='#0000FF'>const</font> <font color='#0000FF'><u>double</u></font> DEFAULT_BATCH_NORM_EPS <font color='#5555FF'>=</font> <font color='#979000'>0.0001</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        layer_mode mode
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='bn_'></a>bn_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a batch normalization layer that
                implements the method described in the paper: 
                    Batch Normalization: Accelerating Deep Network Training by Reducing
                    Internal Covariate Shift by Sergey Ioffe and Christian Szegedy
                
                In particular, this layer produces output tensors with the same
                dimensionality as the input tensors, except that the mean and variances of
                the elements have been standardized to 0 and 1 respectively. 

                It should also be noted that when tensors with a num_samples() dimension of
                1 are passed to this layer it doesn't perform batch normalization.
                Instead, it runs in "inference mode" where the learned linear normalizing
                transformation is used to transform the tensor. 

                Finally, after you finish training a batch normalized network, it is a good
                idea to replace each bn_ layer with an affine_ layer because the affine_
                layer is faster and will never surprise you by performing batch
                normalization on tensors that have a num_samples() dimension &gt; 1.  This allows
                you to run large mini-batches of samples through your final network without
                batch normalization executing at all. 
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='bn_'></a>bn_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_mode() == mode
                - #get_running_stats_window_size()      == 100
                - #get_learning_rate_multiplier()       == 1
                - #get_weight_decay_multiplier()        == 0
                - #get_bias_learning_rate_multiplier()  == 1
                - #get_bias_weight_decay_multiplier()   == 1
                - #get_eps() == tt::DEFAULT_BATCH_NORM_EPS
        !*/</font>

        <font color='#0000FF'>explicit</font> <b><a name='bn_'></a>bn_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> window_size,
            <font color='#0000FF'><u>double</u></font> eps <font color='#5555FF'>=</font> tt::DEFAULT_BATCH_NORM_EPS
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - eps &gt; 0
                - window_size &gt; 0
            ensures
                - #get_mode() == mode 
                - #get_running_stats_window_size()     == window_size
                - #get_learning_rate_multiplier()      == 1
                - #get_weight_decay_multiplier()       == 0
                - #get_bias_learning_rate_multiplier() == 1
                - #get_bias_weight_decay_multiplier()  == 1
                - #get_eps() == eps
        !*/</font>

        layer_mode <b><a name='get_mode'></a>get_mode</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the mode of this layer, either CONV_MODE or FC_MODE.
                  If the mode is FC_MODE then the normalization is applied across the
                  samples in a tensor (i.e. k()*nr()*nc() different things will be
                  normalized).  Otherwise, normalization is applied across everything
                  except for the k() dimension, resulting in there being only k()
                  normalization equations that are applied spatially over the tensor.

                  Therefore, if you are putting batch normalization after a fully connected
                  layer you should use FC_MODE.  Otherwise, if you are putting batch
                  normalization after a convolutional layer you should use CONV_MODE.
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_eps'></a>get_eps</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - When doing batch normalization, we are dividing by the standard
                  deviation.  This epsilon value returned by this function is added to the
                  variance to prevent the division from dividing by zero.
        !*/</font>

        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='get_running_stats_window_size'></a>get_running_stats_window_size</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - Just as recommended in the batch normalization paper, this object keeps a
                  running average of the mean and standard deviations of the features.
                  These averages are used during "inference mode" so you can run a single
                  object through a batch normalized network.  They are also what is used to
                  initialize an affine_ layer that is constructed from a bn_ layer.  This
                  function returns the effective number of recent samples used to compute
                  the running average.
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_running_stats_window_size'></a>set_running_stats_window_size</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> new_window_size
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - new_window_size &gt; 0
            ensures
                - #get_running_stats_window_size() == new_window_size
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;  
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its parameters be
                  multiplied by get_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_weight_decay_multiplier'></a>get_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its parameters be
                  multiplied by get_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_weight_decay_multiplier'></a>set_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_learning_rate_multiplier'></a>get_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the learning rate used to optimize its bias parameters be
                  multiplied by get_learning_rate_multiplier()*get_bias_learning_rate_multiplier().
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_bias_weight_decay_multiplier'></a>get_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns a multiplier number.  The interpretation is that this object is
                  requesting that the weight decay used to optimize its bias parameters be
                  multiplied by get_weight_decay_multiplier()*get_bias_weight_decay_multiplier().
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_learning_rate_multiplier'></a>set_bias_learning_rate_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_learning_rate_multiplier() == val
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='set_bias_weight_decay_multiplier'></a>set_bias_weight_decay_multiplier</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> val
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - val &gt;= 0
            ensures
                - #get_bias_weight_decay_multiplier() == val
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> bn_con <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>bn_<font color='#5555FF'>&lt;</font>CONV_MODE<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> bn_fc <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>bn_<font color='#5555FF'>&lt;</font>FC_MODE<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='affine_'></a>affine_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it applies a simple pointwise linear
                transformation to an input tensor.  You can think of it as having two
                parameter tensors, gamma and beta.  If the input tensor is called INPUT
                then the output of this layer is:
                    gamma*INPUT+beta
                where all operations are performed element wise and each sample in the
                INPUT tensor is processed separately.

                Moreover, this object has two modes that affect the dimensionalities of
                gamma and beta and how they are applied to compute gamma*INPUT+beta.  If
                get_mode()==FC_MODE then gamma and beta each have the same dimensionality
                as the input tensor, except their num_samples() dimensions are 1.  If
                get_mode()==CONV_MODE then gamma and beta have all their dimensions set
                to 1 except for k(), which is equal to INPUT.k().

                In either case, the computation of gamma*INPUT+beta is performed pointwise
                over all the elements of INPUT using either:
                    OUTPUT(n,k,r,c) == gamma(1,k,r,c)*INPUT(n,k,r,c)+beta(1,k,r,c)
                or
                    OUTPUT(n,k,r,c) == gamma(1,k,1,1)*INPUT(n,k,r,c)+beta(1,k,1,1)
                as appropriate.


                Finally, note that the parameters of this layer are not learnable and
                therefore not modified during network updates.  Instead, the layer will
                perform the identity transformation unless it is initialized with a bn_
                layer, in which case it will perform whatever transformation the bn_ layer
                has learned.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='affine_'></a>affine_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_mode() == FC_MODE 
        !*/</font>

        <b><a name='affine_'></a>affine_</b><font face='Lucida Console'>(</font>
            layer_mode mode
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_mode() == mode
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
            layer_mode mode
            <font color='#5555FF'>&gt;</font>
        <b><a name='affine_'></a>affine_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> bn_<font color='#5555FF'>&lt;</font>mode<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> layer
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Constructs affine_ so that it performs the same transformation as the
                  supplied batch normalization layer.  You would want to do this after you
                  finish training a network with bn_ layers because the affine_ layer will
                  execute faster.  
                - #get_mode() == layer.get_mode()
        !*/</font>

        layer_mode <b><a name='get_mode'></a>get_mode</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the mode of this layer, either CONV_MODE or FC_MODE.  
        !*/</font>

        <font color='#0000FF'><u>void</u></font> <b><a name='disable'></a>disable</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_layer_params().size() == 0.
                - when forward_inplace and backward_inplace are called, they return immediately doing nothing.
                  Causing this layer to trivially perform the an identity transform.
        !*/</font>

        alias_tensor_instance <b><a name='get_gamma'></a>get_gamma</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the gamma parameter that defines the behavior of forward().
        !*/</font>

        alias_tensor_const_instance <b><a name='get_gamma'></a>get_gamma</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the gamma parameter that defines the behavior of forward().
        !*/</font>

        alias_tensor_instance <b><a name='get_beta'></a>get_beta</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the beta parameter that defines the behavior of forward().
        !*/</font>

        alias_tensor_const_instance <b><a name='get_beta'></a>get_beta</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the beta parameter that defines the behavior of forward().
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the
            EXAMPLE_COMPUTATIONAL_LAYER_ interface.  Also note that get_layer_params()
            always returns an empty tensor since there are no learnable parameters in this
            object.
        !*/</font>

    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> affine <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>affine_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> _nr,
        <font color='#0000FF'><u>long</u></font> _nc,
        <font color='#0000FF'><u>int</u></font> _stride_y,
        <font color='#0000FF'><u>int</u></font> _stride_x,
        <font color='#0000FF'><u>int</u></font> _padding_y <font color='#5555FF'>=</font> _stride_y<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nr<font color='#5555FF'>/</font><font color='#979000'>2</font>,
        <font color='#0000FF'><u>int</u></font> _padding_x <font color='#5555FF'>=</font> _stride_x<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nc<font color='#5555FF'>/</font><font color='#979000'>2</font>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='max_pool_'></a>max_pool_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - _nr &gt;= 0
                - _nc &gt;= 0
                - _stride_y &gt; 0
                - _stride_x &gt; 0
                - _padding_y &gt;= 0
                - _padding_x &gt;= 0
                - if (_nr != 0) then
                    - _padding_y &lt; _nr
                - else
                    - _padding_y == 0
                - if (_nc != 0) then
                    - _padding_x &lt; _nr
                - else
                    - _padding_x == 0

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a max pooling layer that takes an
                input tensor and downsamples it.  It does this by sliding a window over the
                images in an input tensor and outputting, for each channel, the maximum
                element within the window.  

                If _nr == 0 then it means the filter size covers all the rows in the input
                tensor, similarly for the _nc parameter.  To be precise, if we call the
                input tensor IN and the output tensor OUT, then OUT is defined as follows:
                    - let FILT_NR == (nr()==0) ? IN.nr() : nr()
                    - let FILT_NC == (nc()==0) ? IN.nc() : nc()
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == IN.k()
                    - OUT.nr() == 1+(IN.nr() + 2*padding_y() - FILT_NR)/stride_y()
                    - OUT.nc() == 1+(IN.nc() + 2*padding_x() - FILT_NC)/stride_x()
                    - for all valid s, k, r, and c:
                        - image_plane(OUT,s,k)(r,c) == max(subm_clipped(image_plane(IN,s,k),
                                                                  centered_rect(x*stride_x() + FILT_NC/2 - padding_x(),
                                                                                y*stride_y() + FILT_NR/2 - padding_y(),
                                                                                FILT_NC,
                                                                                FILT_NR)))
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='max_pool_'></a>max_pool_</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #nr() == _nr
                - #nc() == _nc
                - #stride_y() == _stride_y
                - #stride_x() == _stride_x
                - #padding_y() == _padding_y
                - #padding_x() == _padding_x
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nr'></a>nr</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of rows in the pooling window or 0 if the window size
                  is "the entire input tensor".
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nc'></a>nc</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the number of rows in the pooling window or 0 if the window size
                  is "the entire input tensor".
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_y'></a>stride_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the vertical stride used when scanning the max pooling window
                  over an image.  That is, each window will be moved stride_y() pixels down
                  at a time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_x'></a>stride_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the horizontal stride used when scanning the max pooling window
                  over an image.  That is, each window will be moved stride_x() pixels down
                  at a time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_y'></a>padding_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the top and bottom
                  sides of the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_x'></a>padding_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the left and right 
                  sides of the image.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ 
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'><u>int</u></font> stride_y,
        <font color='#0000FF'><u>int</u></font> stride_x,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> max_pool <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>max_pool_<font color='#5555FF'>&lt;</font>nr,nc,stride_y,stride_x<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> max_pool_everything <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>max_pool_<font color='#5555FF'>&lt;</font><font color='#979000'>0</font>,<font color='#979000'>0</font>,<font color='#979000'>1</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> _nr,
        <font color='#0000FF'><u>long</u></font> _nc,
        <font color='#0000FF'><u>int</u></font> _stride_y,
        <font color='#0000FF'><u>int</u></font> _stride_x,
        <font color='#0000FF'><u>int</u></font> _padding_y <font color='#5555FF'>=</font> _stride_y<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nr<font color='#5555FF'>/</font><font color='#979000'>2</font>,
        <font color='#0000FF'><u>int</u></font> _padding_x <font color='#5555FF'>=</font> _stride_x<font color='#5555FF'>!</font><font color='#5555FF'>=</font><font color='#979000'>1</font>? <font color='#979000'>0</font> : _nc<font color='#5555FF'>/</font><font color='#979000'>2</font>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='avg_pool_'></a>avg_pool_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - _nr &gt;= 0
                - _nc &gt;= 0
                - _stride_y &gt; 0
                - _stride_x &gt; 0
                - _padding_y &gt;= 0
                - _padding_x &gt;= 0
                - if (_nr != 0) then
                    - _padding_y &lt; _nr
                - else
                    - _padding_y == 0
                - if (_nc != 0) then
                    - _padding_x &lt; _nr
                - else
                    - _padding_x == 0

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines an average pooling layer that
                takes an input tensor and downsamples it.  It does this by sliding a window
                over the images in an input tensor and outputting, for each channel, the
                average element within the window.  

                If _nr == 0 then it means the filter size covers all the rows in the input
                tensor, similarly for the _nc parameter.  To be precise, if we call the
                input tensor IN and the output tensor OUT, then OUT is defined as follows:
                    - let FILT_NR == (nr()==0) ? IN.nr() : nr()
                    - let FILT_NC == (nc()==0) ? IN.nc() : nc()
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == IN.k()
                    - OUT.nr() == 1+(IN.nr() + 2*padding_y() - FILT_NR)/stride_y()
                    - OUT.nc() == 1+(IN.nc() + 2*padding_x() - FILT_NC)/stride_x()
                    - for all valid s, k, r, and c:
                        - image_plane(OUT,s,k)(r,c) == mean(subm_clipped(image_plane(IN,s,k),
                                                                  centered_rect(x*stride_x() + FILT_NC/2 - padding_x(),
                                                                                y*stride_y() + FILT_NR/2 - padding_y(),
                                                                                FILT_NC,
                                                                                FILT_NR)))
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='avg_pool_'></a>avg_pool_</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #nr() == _nr
                - #nc() == _nc
                - #stride_y() == _stride_y
                - #stride_x() == _stride_x
                - #padding_y() == _padding_y
                - #padding_x() == _padding_x
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nr'></a>nr</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of rows in the pooling window or 0 if the window size
                  is "the entire input tensor".
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='nc'></a>nc</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the number of rows in the pooling window or 0 if the window size
                  is "the entire input tensor".
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_y'></a>stride_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the vertical stride used when scanning the pooling window
                  over an image.  That is, each window will be moved stride_y() pixels down
                  at a time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='stride_x'></a>stride_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the horizontal stride used when scanning the pooling window
                  over an image.  That is, each window will be moved stride_x() pixels down
                  at a time when it moves over the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_y'></a>padding_y</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the top and bottom
                  sides of the image.
        !*/</font>

        <font color='#0000FF'><u>long</u></font> <b><a name='padding_x'></a>padding_x</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - returns the number of pixels of zero padding added to the left and right 
                  sides of the image.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ 
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>

    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'><u>int</u></font> stride_y,
        <font color='#0000FF'><u>int</u></font> stride_x,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> avg_pool <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>avg_pool_<font color='#5555FF'>&lt;</font>nr,nc,stride_y,stride_x<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> avg_pool_everything <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>avg_pool_<font color='#5555FF'>&lt;</font><font color='#979000'>0</font>,<font color='#979000'>0</font>,<font color='#979000'>1</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='relu_'></a>relu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a rectified linear layer.
                Therefore, it passes its inputs through the function 
                    f(x)=max(x,0) 
                where f() is applied pointwise across the input tensor.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='relu_'></a>relu_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'><u>void</u></font> <b><a name='disable'></a>disable</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #get_layer_params().size() == 0.
                - when forward_inplace and backward_inplace are called, they return immediately doing nothing.
                  Causing this layer to trivially perform the an identity transform.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ 
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> relu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>relu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='prelu_'></a>prelu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a parametric rectified linear
                layer.  Therefore, it passes its inputs through the function 
                    f(x) = x&gt;0 ? x : p*x 
                where f() is applied pointwise across the input tensor and p is a scalar
                parameter learned by this layer.


                This is the layer type introduced in the paper:
                    He, Kaiming, et al. "Delving deep into rectifiers: Surpassing
                    human-level performance on imagenet classification." Proceedings of the
                    IEEE International Conference on Computer Vision. 2015.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <font color='#0000FF'>explicit</font> <b><a name='prelu_'></a>prelu_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> initial_param_value <font color='#5555FF'>=</font> <font color='#979000'>0.25</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - The p parameter will be initialized with initial_param_value.
                - #get_initial_param_value() == initial_param_value.
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_initial_param_value'></a>get_initial_param_value</b> <font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the initial value of the prelu parameter. 
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> prelu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>prelu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='leaky_relu_'></a>leaky_relu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a leaky rectified linear
                layer.  Therefore, it passes its inputs through the function
                    f(x) = x&gt;0 ? x : alpha*x
                where f() is applied pointwise across the input tensor and alpha is a
                non-learned scalar.

                This is the layer type introduced in the paper:
                    A. L. Maas, A. Y. Hannun, and A. Y. Ng. "Rectifier nonlinearities improve
                    neural network acoustic models". In ICML, 2013.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#0000FF'>explicit</font> <b><a name='leaky_relu_'></a>leaky_relu_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> alpha <font color='#5555FF'>=</font> <font color='#979000'>0.01f</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - the alpha parameter will be initialized with the alpha value
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_alpha'></a>get_alpha</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the alpha parameter of the leaky_relu
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> leaky_relu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>prelu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='sig_'></a>sig_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a sigmoid layer.  Therefore, it
                passes its inputs through the function 
                    f(x)=1/(1+exp(-x)) 
                where f() is applied pointwise across the input tensor.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='sig_'></a>sig_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ 
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> sig <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>sig_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='mish_'></a>mish_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a mish layer.  Therefore, it
                passes its inputs through the function
                    f(x)= x*tanh(log(1+exp(x)))
                where f() is applied pointwise across the input tensor.

                This is the layer type introduced in the paper:
                Diganta Misra. "Mish: A Self Regularized Non-Monotonic Activation Function"
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='mish_'></a>mish_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> data_output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> mish <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>mish_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='htan_'></a>htan_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a hyperbolic tangent layer.
                Therefore, it passes its inputs through the function 
                    f(x)=std::tanh(x)
                where f() is applied pointwise across the input tensor.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='htan_'></a>htan_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ 
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> htan <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>htan_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='clipped_relu_'></a>clipped_relu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a clipped version of the relu layer.
                Therefore, it passes its inputs through the function
                    f(x) = min(max(x, 0), ceiling)
                where f() is applied pointwise across the input tensor and ceiling is a
                non-learned scalar.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='clipped_relu_'></a>clipped_relu_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> <font color='#0000FF'><u>float</u></font> ceiling <font color='#5555FF'>=</font> <font color='#979000'>6.0f</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - the ceiling parameter will be initialized with the ceiling value
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_ceiling'></a>get_ceiling</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the celiling parameter of the clipped_relu
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> clipped_relu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>clipped_relu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='elu_'></a>elu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines an exponential linear unit.
                Therefore, it passes its inputs through the function
                    f(x) = x&gt;0 ? x : alpha*(exp(x)-1)
                where f() is applied pointwise across the input tensor and alpha is a
                non-learned scalar.

                This is the layer type introduced in the paper:
                Djork-Arné Clevert, Thomas Unterthiner, Sepp Hochreiter.
                "Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)".
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='elu_'></a>elu_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> <font color='#0000FF'><u>float</u></font> alpha <font color='#5555FF'>=</font> <font color='#979000'>1.0f</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - the alpha parameter will be initialized with the alpha value
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_alpha'></a>get_alpha</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the alpha parameter of the elu
        !*/</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> elu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>elu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='gelu_'></a>gelu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a gelu layer.  Therefore, it
                passes its inputs through the function
                        f(x)= x/2 * (1 + erf(x/sqrt(2))
                where f() is applied pointwise across the input tensor.

                This is the layer type introduced in the paper:
                Dan Hendrycks, Kevin Gimpel. "Gaussian Error Linear Units (GELUs)".
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='gelu_'></a>gelu_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> data_output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> gelu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>gelu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='smelu_'></a>smelu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a smooth rectified linear
                layer.  Therefore, it passes its inputs through the function f(x):
                    - if (x &gt; beta) 1
                    - if (x &lt; -beta) 0
                    - else std::pow(x + beta, 2) / (4 * beta)
                where f() is applied pointwise across the input tensor and beta is a
                non-learned scalar.

                This is the layer type introduced in the paper:
                "Smooth activations and reproducibility in deep networks" by
                Gil I. Shamir, Dong Lin, Lorenzo Coviello (https://arxiv.org/abs/2010.09931)
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#0000FF'>explicit</font> <b><a name='smelu_'></a>smelu_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>float</u></font> beta <font color='#5555FF'>=</font> <font color='#979000'>1</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - the beta parameter will be initialized with the beta value
        !*/</font>

        <font color='#0000FF'><u>float</u></font> <b><a name='get_beta'></a>get_beta</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the beta parameter of the smelu
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> smelu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>prelu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='silu_'></a>silu_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a silu layer.  Therefore, it
                passes its inputs through the function
                        f(x)= x * sigmoid(x) = x / (1 + exp(-x))
                where f() is applied pointwise across the input tensor.

                This is the layer type introduced in the paper:
                Dan Hendrycks, Kevin Gimpel. "Gaussian Error Linear Units (GELUs)".
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='silu_'></a>silu_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> data_output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font><font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> silu <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>silu_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>operation_mode s_mode_<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='softmax_'></a>softmax_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above. It defines a softmax layer with two modes of operation:
                channel-wise and plane-wise.

                The softmax function s(x) is defined as:
                    s(x) == exp(x)/sum(exp(x))
                where x is a vector.

                1. Channel-wise mode (s_mode_ == CHANNEL_WISE):
                This mode treats the input tensor as a collection of multi-channel images
                and applies s() to each spatial location in each image. The tensor::k()
                channel elements at each position are input to s() and then replaced by
                the outputs of s().

                2. Plane-wise mode (s_mode_ == PLANE_WISE):
                This mode applies the softmax function across entire planes (nr x nc) of
                the input tensor, useful for operations in Large Language Models (LLMs)
                and other applications requiring 2D tensor processing.

                In both modes, the sum of the outputs of s() will always be equal to 1 for
                each application of the function.

            TEMPLATE PARAMETERS
                - s_mode_: Determines the mode of operation (CHANNEL_WISE or PLANE_WISE)
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='softmax_'></a>softmax_</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output,
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input,
            tensor<font color='#5555FF'>&amp;</font> data_grad,
            tensor<font color='#5555FF'>&amp;</font> params_grad
        <font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_
            interface. Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> softmax_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>softmax_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> std::ostream<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>std::ostream<font color='#5555FF'>&amp;</font> out, <font color='#0000FF'>const</font> softmax_<font color='#5555FF'>&amp;</font> item<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='to_xml'></a>to_xml</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> softmax_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> softmax <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>softmax_<font color='#5555FF'>&lt;</font>operation_mode::CHANNEL_WISE<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> softmaxm <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>softmax_<font color='#5555FF'>&lt;</font>operation_mode::PLANE_WISE<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='softmax_all_'></a>softmax_all_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, it defines a softmax layer.  To be precise,
                we define the softmax function s(x) as:
                    s(x) == exp(x)/sum(exp(x)) 
                where x is a vector.  Then this layer treats its input tensor as a
                collection of tensor::num_samples() vectors and applies s() to each vector
                in the tensor.  Therefore, there are logically tensor::num_samples()
                invocations of s().
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='softmax_all_'></a>softmax_all_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ 
            interface.  Note that this layer doesn't have any parameters, so the tensor
            returned by get_layer_params() is always empty.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> softmax_all <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>softmax_all_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='add_prev_'></a>add_prev_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  This layer simply adds the output of two previous layers.
                In particular, it adds the tensor from its immediate predecessor layer,
                sub.get_output(), with the tensor from a deeper layer,
                layer&lt;tag&gt;(sub).get_output().

                Therefore, you supply a tag via add_prev_'s template argument that tells it
                what layer to add to the output of the previous layer.  The result of this
                addition is output by add_prev_.  Finally, the addition happens pointwise
                according to 4D tensor arithmetic.  If the dimensions don't match then
                missing elements are presumed to be equal to 0.  Moreover, each dimension
                of the output tensor is equal to the maximum dimension of either of the
                inputs.  That is, if the tensors A and B are being added to produce C then:
                    - C.num_samples() == max(A.num_samples(), B.num_samples())
                    - C.k()  == max(A.k(), B.k())
                    - C.nr() == max(A.nr(), B.nr())
                    - C.nc() == max(A.nc(), B.nc())
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='add_prev_'></a>add_prev_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>; 

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;


    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> add_prev <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>add_prev_<font color='#5555FF'>&lt;</font>tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// Here we add some convenient aliases for using add_prev_ with the tag layers. 
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev1  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag1, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev2  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag2, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev3  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag3, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev4  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag4, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev5  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag5, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev6  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag6, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev7  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag7, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev8  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag8, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev9  <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag9, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> add_prev10 <font color='#5555FF'>=</font> add_prev<font color='#5555FF'>&lt;</font>tag10, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev1_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag1<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev2_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag2<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev3_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag3<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev4_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag4<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev5_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag5<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev6_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag6<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev7_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag7<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev8_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag8<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev9_  <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag9<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> add_prev10_ <font color='#5555FF'>=</font> add_prev_<font color='#5555FF'>&lt;</font>tag10<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='mult_prev_'></a>mult_prev_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  This layer simply multiplies the output of two previous
                layers.  In particular, it multiplies the tensor from its immediate
                predecessor layer, sub.get_output(), with the tensor from a deeper layer,
                layer&lt;tag&gt;(sub).get_output().

                Therefore, you supply a tag via mult_prev_'s template argument that tells
                it what layer to multiply with the output of the previous layer.  The
                result of this multiplication is output by mult_prev_.  Finally, the
                multiplication happens pointwise according to 4D tensor arithmetic.  If the
                dimensions don't match then missing elements are presumed to be equal to 0.
                Moreover, each dimension of the output tensor is equal to the maximum
                dimension of either of the inputs.  That is, if the tensors A and B are
                being multiplied to produce C then:
                    - C.num_samples() == max(A.num_samples(), B.num_samples())
                    - C.k()  == max(A.k(), B.k())
                    - C.nr() == max(A.nr(), B.nr())
                    - C.nc() == max(A.nc(), B.nc())
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='mult_prev_'></a>mult_prev_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>; 

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;


    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> mult_prev <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>mult_prev_<font color='#5555FF'>&lt;</font>tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// Here we add some convenient aliases for using mult_prev_ with the tag layers. 
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev1  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag1, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev2  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag2, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev3  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag3, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev4  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag4, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev5  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag5, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev6  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag6, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev7  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag7, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev8  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag8, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev9  <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag9, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> mult_prev10 <font color='#5555FF'>=</font> mult_prev<font color='#5555FF'>&lt;</font>tag10, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev1_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag1<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev2_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag2<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev3_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag3<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev4_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag4<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev5_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag5<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev6_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag6<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev7_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag7<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev8_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag8<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev9_  <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag9<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> mult_prev10_ <font color='#5555FF'>=</font> mult_prev_<font color='#5555FF'>&lt;</font>tag10<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='multm_prev_'></a>multm_prev_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above. This layer performs matrix multiplication on the output
                of two previous layers. It multiplies the tensor from its immediate
                predecessor layer, sub.get_output(), with the tensor from a deeper layer,
                layer&lt;tag&gt;(sub).get_output().

                The tag template argument specifies which layer to multiply with the
                output of the previous layer. The result of this multiplication is
                output by multm_prev_. The multiplication is performed using a modified
                version of gemm() to account for the 2D matrix dimension in the nr()xnc()
                planes of Dlib's 4D tensors.

                This layer is similar to mult_prev_, but it considers the full matrix
                in the nr()xnc() planes of the tensor, rather than just the upper
                num_samples()xk() plane. This makes it suitable for implementing
                mechanisms like attention, especially when the k() channel plane is
                used to model multiple heads for parallel matrix processing.

                The output tensor dimensions are determined as follows:
                    - output.num_samples() == t1.num_samples()
                    - output.k() == t1.k()
                    - output.nr() == t1.nr()
                    - output.nc() == t2.nc()
                where t1 is sub.get_output() and t2 is layer&lt;tag&gt;(sub).get_output().
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='multm_prev_'></a>multm_prev_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>; 

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;        
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> multm_prev <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>multm_prev_<font color='#5555FF'>&lt;</font>tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// Here we add some convenient aliases for using multm_prev_ with the tag layers. 
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev1  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag1, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev2  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag2, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev3  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag3, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev4  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag4, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev5  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag5, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev6  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag6, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev7  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag7, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev8  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag8, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev9  <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag9, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> multm_prev10 <font color='#5555FF'>=</font> multm_prev<font color='#5555FF'>&lt;</font>tag10, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev1_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag1<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev2_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag2<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev3_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag3<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev4_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag4<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev5_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag5<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev6_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag6<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev7_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag7<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev8_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag8<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev9_  <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag9<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> multm_prev10_ <font color='#5555FF'>=</font> multm_prev_<font color='#5555FF'>&lt;</font>tag10<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='resize_prev_to_tagged_'></a>resize_prev_to_tagged_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  This layer resizes the output channels of the previous layer
                to have the same number of rows and columns as the output of the tagged layer.

                This layer uses bilinear interpolation. If the sizes match already, then it
                simply copies the data.

                Therefore, you supply a tag via resize_prev_to_tagged's template argument that
                tells it what layer to use for the target size.

                If tensor PREV is resized to size of tensor TAGGED, then a tensor OUT is
                produced such that:
                    - OUT.num_samples() == PREV.num_samples()
                    - OUT.k()  == PREV.k()
                    - OUT.nr() == TAGGED.nr()
                    - OUT.nc() == TAGGED.nc()
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='resize_prev_to_tagged_'></a>resize_prev_to_tagged_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>; 

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;


    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> resize_prev_to_tagged <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>resize_prev_to_tagged_<font color='#5555FF'>&lt;</font>tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='scale_'></a>scale_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  This layer scales the output channels of the tagged layer
                by multiplying it with the output of the previous layer.  To be specific:
                    - Let INPUT  == layer&lt;tag&gt;(sub).get_output()
                    - Let SCALES == sub.get_output()
                    - This layer takes INPUT and SCALES as input.
                    - The output of this layer has the same dimensions as INPUT.
                    - This layer requires:
                        - SCALES.num_samples() == INPUT.num_samples()
                        - SCALES.k()  == INPUT.k()
                        - SCALES.nr() == 1
                        - SCALES.nc() == 1
                    - The output tensor is produced by pointwise multiplying SCALES with
                      INPUT at each spatial location.  Therefore, if OUT is the output of
                      this layer then we would have:
                        OUT(n,k,r,c) == INPUT(n,k,r,c)*SCALES(n,k)
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='scale_'></a>scale_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>; 

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;


    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> scale <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>scale_<font color='#5555FF'>&lt;</font>tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// Here we add some convenient aliases for using scale_ with the tag layers. 
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale1  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag1, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale2  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag2, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale3  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag3, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale4  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag4, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale5  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag5, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale6  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag6, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale7  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag7, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale8  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag8, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale9  <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag9, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale10 <font color='#5555FF'>=</font> scale<font color='#5555FF'>&lt;</font>tag10, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale1_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag1<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale2_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag2<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale3_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag3<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale4_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag4<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale5_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag5<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale6_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag6<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale7_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag7<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale8_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag8<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale9_  <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag9<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale10_ <font color='#5555FF'>=</font> scale_<font color='#5555FF'>&lt;</font>tag10<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='scale_prev_'></a>scale_prev_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  This layer scales the output channels of the tagged layer
                by multiplying it with the output of the previous layer.  It is excatly the
                same as the scale_ layer, but with the inputs swapped, which is useful since
                it allows mapping between inputs and outputs of this layer.  To be specific:
                    - Let INPUT == sub.get_output()
                    - Let SCALES == layer&lt;tag&gt;(sub).get_output()
                    - This layer takes INPUT and SCALES as input.
                    - The output of this layer has the same dimensions as INPUT.
                    - This layer requires:
                        - SCALES.num_samples() == INPUT.num_samples()
                        - SCALES.k()  == INPUT.k()
                        - SCALES.nr() == 1
                        - SCALES.nc() == 1
                    - The output tensor is produced by pointwise multiplying SCALES with
                      INPUT at each spatial location.  Therefore, if OUT is the output of
                      this layer then we would have:
                        OUT(n,k,r,c) == INPUT(n,k,r,c)*SCALES(n,k)
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='scale_prev_'></a>scale_prev_</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;


    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='tag'></a>tag</b>,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> scale_prev <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>scale_prev_<font color='#5555FF'>&lt;</font>tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// Here we add some convenient aliases for using scale_prev_ with the tag layers.
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev1  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag1, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev2  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag2, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev3  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag3, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev4  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag4, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev5  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag5, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev6  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag6, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev7  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag7, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev8  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag8, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev9  <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag9, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> scale_prev10 <font color='#5555FF'>=</font> scale_prev<font color='#5555FF'>&lt;</font>tag10, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev1_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag1<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev2_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag2<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev3_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag3<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev4_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag4<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev5_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag5<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev6_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag6<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev7_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag7<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev8_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag8<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev9_  <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag9<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>using</font> scale_prev10_ <font color='#5555FF'>=</font> scale_prev_<font color='#5555FF'>&lt;</font>tag10<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font>... <b><a name='TAG_TYPES'></a>TAG_TYPES</b>
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='concat_'></a>concat_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  This layer simply concatenates the output of tagged layers.
                Importantly, each input layer must have the same dimensions (i.e.
                num_samples, nr, and nc) except for the k channel, which may vary.  This is
                because the concatenation happens along the k dimension.  That is, the
                output of this network is a tensor, OUT, that is the concatenation of the
                tensors:
                    for each (tag in TAG_TYPES)
                        layer&lt;tag&gt;(subnet).get_output()
                Therefore, out.num_samples(), out.nr(), and out.nc() match the dimensions
                of the input tensors while OUT.k() is the sum of the input layer's k()
                dimensions.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;


    <font color='#009900'>// concat layer definitions
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG1'></a>TAG1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG2'></a>TAG2</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> concat2 <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>concat_<font color='#5555FF'>&lt;</font>TAG1, TAG2<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG1'></a>TAG1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG2'></a>TAG2</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG3'></a>TAG3</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> concat3 <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>concat_<font color='#5555FF'>&lt;</font>TAG1, TAG2, TAG3<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG1'></a>TAG1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG2'></a>TAG2</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG3'></a>TAG3</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG4'></a>TAG4</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> concat4 <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>concat_<font color='#5555FF'>&lt;</font>TAG1, TAG2, TAG3, TAG4<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG1'></a>TAG1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG2'></a>TAG2</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG3'></a>TAG3</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG4'></a>TAG4</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font> <font color='#0000FF'>class</font> <b><a name='TAG5'></a>TAG5</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> concat5 <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>concat_<font color='#5555FF'>&lt;</font>TAG1, TAG2, TAG3, TAG4, TAG5<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>    
    <a name='inception'/><font color='#009900'>/*!A inception layer definitions !*/</font>

    <font color='#009900'>// Now define inception layer tag types.  These layer aliases allow creating
</font>    <font color='#009900'>// the networks described in the paper: 
</font>    <font color='#009900'>//   Szegedy, Christian, et al. "Going deeper with convolutions." Proceedings of
</font>    <font color='#009900'>//   the IEEE Conference on Computer Vision and Pattern Recognition. 2015.
</font>    <font color='#009900'>// See the dnn_inception_ex.cpp example for a complete example of their use.  Note also
</font>    <font color='#009900'>// that we use tag ID numbers &gt;= 1000 to avoid conflict with user's tag layers.
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> itag0  <font color='#5555FF'>=</font> add_tag_layer<font color='#5555FF'>&lt;</font> <font color='#979000'>1000</font> <font color='#5555FF'>+</font> <font color='#979000'>0</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> itag1  <font color='#5555FF'>=</font> add_tag_layer<font color='#5555FF'>&lt;</font> <font color='#979000'>1000</font> <font color='#5555FF'>+</font> <font color='#979000'>1</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> itag2  <font color='#5555FF'>=</font> add_tag_layer<font color='#5555FF'>&lt;</font> <font color='#979000'>1000</font> <font color='#5555FF'>+</font> <font color='#979000'>2</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> itag3  <font color='#5555FF'>=</font> add_tag_layer<font color='#5555FF'>&lt;</font> <font color='#979000'>1000</font> <font color='#5555FF'>+</font> <font color='#979000'>3</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> itag4  <font color='#5555FF'>=</font> add_tag_layer<font color='#5555FF'>&lt;</font> <font color='#979000'>1000</font> <font color='#5555FF'>+</font> <font color='#979000'>4</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> itag5  <font color='#5555FF'>=</font> add_tag_layer<font color='#5555FF'>&lt;</font> <font color='#979000'>1000</font> <font color='#5555FF'>+</font> <font color='#979000'>5</font>, SUBNET<font color='#5555FF'>&gt;</font>;
    <font color='#009900'>// skip to inception input
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'>using</font> iskip  <font color='#5555FF'>=</font> add_skip_layer<font color='#5555FF'>&lt;</font> itag0, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#009900'>// here are some templates to be used for creating inception layer groups
</font>    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B1'></a>B1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B2'></a>B2</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> inception2 <font color='#5555FF'>=</font> concat2<font color='#5555FF'>&lt;</font>itag1, itag2, itag1<font color='#5555FF'>&lt;</font>B1<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag2<font color='#5555FF'>&lt;</font>B2<font color='#5555FF'>&lt;</font> itag0<font color='#5555FF'>&lt;</font>SUBNET<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B1'></a>B1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B2'></a>B2</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B3'></a>B3</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> inception3 <font color='#5555FF'>=</font> concat3<font color='#5555FF'>&lt;</font>itag1, itag2, itag3, itag1<font color='#5555FF'>&lt;</font>B1<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag2<font color='#5555FF'>&lt;</font>B2<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag3<font color='#5555FF'>&lt;</font>B3<font color='#5555FF'>&lt;</font>  itag0<font color='#5555FF'>&lt;</font>SUBNET<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B1'></a>B1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B2'></a>B2</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B3'></a>B3</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B4'></a>B4</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> inception4 <font color='#5555FF'>=</font> concat4<font color='#5555FF'>&lt;</font>itag1, itag2, itag3, itag4,
                itag1<font color='#5555FF'>&lt;</font>B1<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag2<font color='#5555FF'>&lt;</font>B2<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag3<font color='#5555FF'>&lt;</font>B3<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font>  itag4<font color='#5555FF'>&lt;</font>B4<font color='#5555FF'>&lt;</font>  itag0<font color='#5555FF'>&lt;</font>SUBNET<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B1'></a>B1</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B2'></a>B2</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B3'></a>B3</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B4'></a>B4</b>,
              <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font><font color='#5555FF'>&gt;</font><font color='#0000FF'>class</font> <b><a name='B5'></a>B5</b>,
              <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> inception5 <font color='#5555FF'>=</font> concat5<font color='#5555FF'>&lt;</font>itag1, itag2, itag3, itag4, itag5,
                itag1<font color='#5555FF'>&lt;</font>B1<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag2<font color='#5555FF'>&lt;</font>B2<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font> itag3<font color='#5555FF'>&lt;</font>B3<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font>  itag4<font color='#5555FF'>&lt;</font>B4<font color='#5555FF'>&lt;</font>iskip<font color='#5555FF'>&lt;</font>  itag5<font color='#5555FF'>&lt;</font>B5<font color='#5555FF'>&lt;</font>  itag0<font color='#5555FF'>&lt;</font>SUBNET<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>const</font> <font color='#0000FF'><u>double</u></font> DEFAULT_L2_NORM_EPS <font color='#5555FF'>=</font> <font color='#979000'>1e</font><font color='#5555FF'>-</font><font color='#979000'>5</font>;

    <font color='#0000FF'>class</font> <b><a name='l2normalize_'></a>l2normalize_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  It takes tensors as input and L2 normalizes them.  In particular,
                it has the following properties:
                    - The output tensors from this layer have the same dimensions as the
                      input tensors.
                    - If you think of each input tensor as a set of tensor::num_samples()
                      vectors, then the output tensor contains the same vectors except they
                      have been length normalized so that their L2 norms are all 1.  I.e. 
                      for each vector v we will have ||v||==1.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <font color='#0000FF'>explicit</font> <b><a name='l2normalize_'></a>l2normalize_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>double</u></font> eps <font color='#5555FF'>=</font> tt::DEFAULT_L2_NORM_EPS
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - eps &gt; 0
            ensures
                - #get_eps() == eps
        !*/</font>

        <font color='#0000FF'><u>double</u></font> <b><a name='get_eps'></a>get_eps</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        <font color='#009900'>/*!
            ensures
                - When we normalize a vector we divide it by its L2 norm.  However, the
                  get_eps() value is added to the squared norm prior to division to avoid
                  ever dividing by zero. 
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='forward_inplace'></a>forward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> input, tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='backward_inplace'></a>backward_inplace</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> computed_output, <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, tensor<font color='#5555FF'>&amp;</font> data_grad, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> _offset,
        <font color='#0000FF'><u>long</u></font> _k,
        <font color='#0000FF'><u>long</u></font> _nr,
        <font color='#0000FF'><u>long</u></font> _nc
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='extract_'></a>extract_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - 0 &lt;= _offset
                - 0 &lt; _k
                - 0 &lt; _nr
                - 0 &lt; _nc

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, the output of this layer is simply a copy of
                the input tensor.  However, you can configure the extract layer to output
                only some subset of the input tensor and also to reshape it.  Therefore,
                the dimensions of the tensor output by this layer are as follows (letting
                IN be the input tensor and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == _k 
                    - OUT.nr() == _nr 
                    - OUT.nc() == _nc 

                So the output will always have the same number of samples as the input, but
                within each sample (the k,nr,nc part) we will copy only a subset of the
                values.  Moreover, the _offset parameter controls which part of each sample
                we take.  To be very precise, we will have:
                    - let IN_SIZE   = IN.k()*IN.nr()*IN.nc()
                    - let OUT_SIZE  = _k*_nr*_nc 
                    - for i in range[0,IN.num_samples()) and j in range[0,OUT_SIZE):
                        - OUT.host()[i*OUT_SIZE+j] == IN.host()[i*IN_SIZE+_offset+j]


                Finally, all this means that the input tensor to this layer must have a big
                enough size to accommodate taking a _k*_nr*_nc slice from each of its
                samples.  
        !*/</font>

    <font color='#0000FF'>public</font>:

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> offset,
        <font color='#0000FF'><u>long</u></font> k,
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> extract <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>extract_<font color='#5555FF'>&lt;</font>offset,k,nr,nc<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> _offset_k,
        <font color='#0000FF'><u>long</u></font> _offset_nr,
        <font color='#0000FF'><u>long</u></font> _offset_nc,
        <font color='#0000FF'><u>long</u></font> _k,
        <font color='#0000FF'><u>long</u></font> _nr,
        <font color='#0000FF'><u>long</u></font> _nc
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='slice_'></a>slice_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - 0 &lt;= _offset_k
                - 0 &lt;= _offset_nr
                - 0 &lt;= _offset_nc
                - 0 &lt; _k
                - 0 &lt; _nr
                - 0 &lt; _nc

            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above.  In particular, the output of this layer is simply a copy of
                the input tensor. It is similar to extract in that you can configure the
                slice layer to output only some subset of the input tensor, but slice allows
                copies of non-contiguous regions of the input which enables three dimensional
                cropping of a tensor. The dimensions of the tensor output by this layer
                are as follows (letting IN be the input tensor and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == _k 
                    - OUT.nr() == _nr 
                    - OUT.nc() == _nc 

                So the output will always have the same number of samples as the input, but
                within each sample (the k,nr,nc part) we will copy only a subset of the
                values. Moreover, the _offset_k, _offset_nr, and _offset_nc parameters
                control which channels, rows, and columns of each sample we take.
                To be very precise, we will have:
                    - let IN_SIZE   = IN.k()*IN.nr()*IN.nc()
                    - let OUT_SIZE  = _k*_nr*_nc 
                    - for i in range[0,IN.num_samples()) and j in range[0,OUT_SIZE):
                        - let k = (j / (OUT.nr()*OUT.nc())) % OUT.k()
                        - let r = (j / OUT.nc()) % IN.nr()
                        - let c = j % OUT.nc()
                        - OUT.host()[i*OUT_SIZE+j] == IN.host()[i*IN_SIZE+
                                                                k_stride*(_offset_k+k)+
                                                                row_stride*(_offset_nr+r)+
                                                                col_stride*(_offset_nc+c)]


                Finally, all this means that the input tensor to this layer must have a big
                enough size to accommodate taking a _k*_nr*_nc slice from each of its
                samples.  
        !*/</font>

    <font color='#0000FF'>public</font>:

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>long</u></font> offset_k,
        <font color='#0000FF'><u>long</u></font> offset_nr,
        <font color='#0000FF'><u>long</u></font> offset_nc,
        <font color='#0000FF'><u>long</u></font> k,
        <font color='#0000FF'><u>long</u></font> nr,
        <font color='#0000FF'><u>long</u></font> nc,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> slice <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>slice_<font color='#5555FF'>&lt;</font>offset_k,offset_nr,offset_nc,k,nr,nc<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>long</u></font> <font color='#0000FF'><u>long</u></font> row_stride <font color='#5555FF'>=</font> <font color='#979000'>2</font>, <font color='#0000FF'><u>long</u></font> <font color='#0000FF'><u>long</u></font> col_stride <font color='#5555FF'>=</font> <font color='#979000'>2</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='reorg_'></a>reorg_</b>
    <b>{</b>
        <font color='#009900'>/*!
            REQUIREMENTS ON TEMPLATE ARGUMENTS
                - row_stride &gt;= 1
                - col_stride &gt;= 1

            WHAT THIS OBJECT REPRESENTS
                This class implements the EXAMPLE_COMPUTATIONAL_LAYER_ interface, performing a 
                reorganization of tensor data. It rearranges spatial information along the channel
                dimension, effectively "folding" spatial dimensions into channels.
                
                The dimensions of the output tensor are as follows (letting IN be the input tensor
                and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == IN.k() * row_stride * col_stride
                    - OUT.nr() == IN.nr() / row_stride
                    - OUT.nc() == IN.nc() / col_stride

                Therefore, the output tensor maintains the same number of samples as the input but
                alters the channel and spatial dimensions based on the specified strides.
                
                Specifically, for all n, k, r, c in OUT:
                    OUT.host[tensor_index(OUT, n, k, r, c)] ==
                    IN.host[tensor_index(IN,
                                        n,
                                        k % IN.k(),
                                        r * row_stride + (k / IN.k()) / col_stride,
                                        c * col_stride + (k / IN.k()) % col_stride)]

                **Enhancement Note:**  
                The underlying utility functions (`reorg` and `reorg_gradient`) now include an
                optional `bool add_to` parameter. While the current implementation uses the default
                value to maintain existing behavior, this parameter allows for future reversible
                operations and gradient accumulation flexibility within neural network layers.

                You can think of this layer as an alternative to a strided convolutional layer for
                downsampling tensors, offering similar spatial reduction with different internal
                gradient propagation mechanics.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b> <font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b> <font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> reorg <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>reorg_<font color='#5555FF'>&lt;</font><font color='#979000'>2</font>, <font color='#979000'>2</font><font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='transpose_'></a>transpose_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface
                defined above. In particular, this layer performs a 2D matrix transposition
                on each of the k planes within each sample of a 4D tensor.

                The dimensions of the tensor output by this layer are as follows (letting
                IN be the input tensor and OUT the output tensor):
                    - OUT.num_samples() == IN.num_samples()
                    - OUT.k()  == IN.k()
                    - OUT.nr() == IN.nc()
                    - OUT.nc() == IN.nr()

                The transposition is performed as follows:
                    - For each sample i and each k-plane j:
                        - OUT[i][j][r][c] = IN[i][j][c][r] for all r in [0, IN.nc()) and c in [0, IN.nr())

                This layer does not have any learnable parameters.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='transpose_'></a>transpose_</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>default</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        
        <font color='#0000FF'>inline</font> dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'>inline</font> dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font>dpoint p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>; 
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>; 

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> transpose_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>transpose_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;

        <font color='#0000FF'>friend</font> std::ostream<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>std::ostream<font color='#5555FF'>&amp;</font> out, <font color='#0000FF'>const</font> transpose_<font color='#5555FF'>&amp;</font> item<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='to_xml'></a>to_xml</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> transpose_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;

        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <font color='#0000FF'>private</font>:
        resizable_tensor params; <font color='#009900'>// unused
</font>    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> transpose <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>transpose_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>class</font> <b><a name='positional_encodings_'></a>positional_encodings_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This is an implementation of the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
                It defines a positional encoding layer that adds position information to
                the input tensor. This is particularly useful in transformer architectures
                where the order of the sequence matters.

                The dimensions of the tensors output by this layer are the same as the input
                tensor dimensions.

                This implementation is based on the positional encoding described in:
                Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., 
                Kaiser, Ł., &amp; Polosukhin, I. (2017). Attention is all you need. In Advances 
                in neural information processing systems (pp. 5998-6008).

                The encoding uses sine and cosine functions of different frequencies:
                PE(pos, 2i)   = sin(pos / 10000^(2i/d_model))
                PE(pos, 2i+1) = cos(pos / 10000^(2i/d_model))
                where pos is the position and i is the dimension.
        !*/</font>

    <font color='#0000FF'>public</font>:

        <b><a name='positional_encodings_'></a>positional_encodings_</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> sequence_dim_ <font color='#5555FF'>=</font> <font color='#979000'>1</font>,
            <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> embedding_dim_ <font color='#5555FF'>=</font> <font color='#979000'>1</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - #sequence_dim == sequence_dim_
                - #embedding_dim == embedding_dim_
        !*/</font>

        <b><a name='positional_encodings_'></a>positional_encodings_</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> positional_encodings_<font color='#5555FF'>&amp;</font> item
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - EXAMPLE_COMPUTATIONAL_LAYER_ objects are copy constructable
        !*/</font>

        positional_encodings_<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>=</font><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> positional_encodings_<font color='#5555FF'>&amp;</font> item
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - EXAMPLE_COMPUTATIONAL_LAYER_ objects are assignable
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
            ensures
                - performs any necessary setup for the layer, including the calculation
                of positional encodings based on the dimensions of the input.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub,
            resizable_tensor<font color='#5555FF'>&amp;</font> output
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
                - setup() has been called.
            ensures
                - Adds the positional encodings to the output of the subnetwork and 
                stores the results into #output.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input,
            SUBNET<font color='#5555FF'>&amp;</font> sub,
            tensor<font color='#5555FF'>&amp;</font> params_grad
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET implements the SUBNET interface defined at the top of this file.
                - setup() has been called.
                - #params_grad is unused in this layer as there are no learnable parameters.
            ensures
                - Computes the gradient of the layer with respect to the input, which
                is simply the input gradient itself as positional encodings are constant.
        !*/</font>

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the parameters that define the behavior of forward().
                Note: This layer has no learnable parameters, so this returns an empty tensor.
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the parameters that define the behavior of forward().
                Note: This layer has no learnable parameters, so this returns an empty tensor.
        !*/</font>

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_positional_encodings'></a>get_positional_encodings</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - returns the computed positional encodings.
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_positional_encodings'></a>get_positional_encodings</b><font face='Lucida Console'>(</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - returns the computed positional encodings.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> positional_encodings_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>positional_encodings_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            provides serialization support
        !*/</font>

        <font color='#0000FF'>friend</font> std::ostream<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>std::ostream<font color='#5555FF'>&amp;</font> out, <font color='#0000FF'>const</font> positional_encodings_<font color='#5555FF'>&amp;</font> item<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            print a string describing this layer.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='to_xml'></a>to_xml</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> positional_encodings_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            This function is optional, but required if you want to print your networks with
            net_to_xml(). It prints a layer as XML.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> positional_encodings <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>positional_encodings_, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_embeddings_,
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> embedding_dim_
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='embeddings_'></a>embeddings_</b>
    <b>{</b>
        <font color='#009900'>/*!
            WHAT THIS OBJECT REPRESENTS
                This object represents an embedding layer in a neural network. It maps discrete
                tokens to continuous vector representations. This is a fundamental technique in
                natural language processing and other domains dealing with categorical data.

                The layer takes as input a tensor of integer indices and outputs a tensor of 
                the same shape (except for the last dimension) where each index is replaced by 
                its corresponding embedding vector.

                For more information on embeddings, see:
                Mikolov, T., Sutskever, I., Chen, K., Corrado, G. S., &amp; Dean, J. (2013). 
                Distributed representations of words and phrases and their compositionality. 
                In Advances in neural information processing systems (pp. 3111-3119).

            TEMPLATE PARAMETERS
                - num_embeddings_: The size of the embedding dictionary, i.e., the number of 
                                discrete tokens that can be embedded.
                - embedding_dim_: The dimensionality of each embedding vector.

            CONVENTION
                - get_embeddings() returns the tensor of embedding vectors.
                - get_num_embeddings() == num_embeddings_
                - get_embedding_dim() == embedding_dim_
                - get_learning_rate_multiplier() returns the learning rate multiplier for this layer.
                - get_scale_by_freq() returns whether to scale gradients by token frequency.
        */</font>        
    <font color='#0000FF'>public</font>:
        <b><a name='embeddings_'></a>embeddings_</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>default</font>;

        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='get_num_embeddings'></a>get_num_embeddings</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='get_embedding_dim'></a>get_embedding_dim</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'><u>double</u></font> <b><a name='get_learning_rate_multiplier'></a>get_learning_rate_multiplier</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#0000FF'><u>bool</u></font> <b><a name='get_scale_by_freq'></a>get_scale_by_freq</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;

        <font color='#0000FF'><u>void</u></font> <b><a name='set_num_embeddings'></a>set_num_embeddings</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='set_embedding_dim'></a>set_embedding_dim</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> dim<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='set_learning_rate_multiplier'></a>set_learning_rate_multiplier</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>double</u></font> val<font face='Lucida Console'>)</font>;
        <font color='#0000FF'><u>void</u></font> <b><a name='set_scale_by_freq'></a>set_scale_by_freq</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>bool</u></font> val<font face='Lucida Console'>)</font>;

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font> <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_embeddings'></a>get_embeddings</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_embeddings'></a>get_embeddings</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> embeddings_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>embeddings_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> std::ostream<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>std::ostream<font color='#5555FF'>&amp;</font> out, <font color='#0000FF'>const</font> embeddings_<font color='#5555FF'>&amp;</font> item<font face='Lucida Console'>)</font>;
        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='to_xml'></a>to_xml</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> embeddings_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;

        <font color='#009900'>/*!
            These functions are implemented as described in the EXAMPLE_COMPUTATIONAL_LAYER_ interface.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_embeddings,
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> embedding_dim,
        <font color='#0000FF'>typename</font> SUBNET
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> embeddings <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>embeddings_<font color='#5555FF'>&lt;</font>num_embeddings, embedding_dim<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>struct</font> <b><a name='neg_infinity_tag'></a>neg_infinity_tag</b> <b>{</b><b>}</b>;
    <font color='#0000FF'>struct</font> <b><a name='zero_tag'></a>zero_tag</b> <b>{</b><b>}</b>;

    <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>struct</font> <b><a name='is_special_value'></a>is_special_value</b> : std::false_type <b>{</b><b>}</b>;
    <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>struct</font> <b><a name='is_special_value'></a>is_special_value</b><font color='#5555FF'>&lt;</font>neg_infinity_tag<font color='#5555FF'>&gt;</font> : std::true_type <b>{</b><b>}</b>;
    <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>struct</font> <b><a name='is_special_value'></a>is_special_value</b><font color='#5555FF'>&lt;</font>zero_tag<font color='#5555FF'>&gt;</font> : std::true_type <b>{</b><b>}</b>;

    <font color='#0000FF'>template</font><font color='#5555FF'>&lt;</font><font color='#0000FF'><u>long</u></font> diag_, <font color='#0000FF'>typename</font> tag_, <font color='#0000FF'><u>long</u></font> num_ <font color='#5555FF'>=</font> <font color='#979000'>0</font>, <font color='#0000FF'><u>long</u></font> den_ <font color='#5555FF'>=</font> <font color='#979000'>1</font><font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>class</font> <b><a name='tril_'></a>tril_</b>
    <b>{</b>
        <font color='#009900'>/*!
            TEMPLATE PARAMETERS
                - diag_: A long integer specifying the diagonal offset.
                - tag_: A type tag specifying special values or void for numeric values.
                - num_: Numerator for numeric diagonal value (default is 0, only used if tag_ is void).
                - den_: Denominator for numeric diagonal value (default is 1, only used if tag_ is void).

            REQUIREMENTS
                - diag_ must be an integer.
                - tag_ must be either neg_infinity_tag, zero_tag, or void.
                - If tag_ is void, num_ and den_ are used to compute the diagonal value.
                - If tag_ is neg_infinity_tag or zero_tag, num_ and den_ are ignored.

            WHAT THIS OBJECT REPRESENTS
                This object implements a layer in a deep neural network that applies a lower triangular mask to
                its input tensor. The mask is defined such that all elements above the specified diagonal are set
                to a given value. The diagonal offset and the mask value are determined by the template parameters.

            DIAGONAL VALUE DETERMINATION
                - If tag_ is neg_infinity_tag: diagonal value is set to negative infinity.
                - If tag_ is zero_tag: diagonal value is set to zero.
                - If tag_ is void: diagonal value is set to num_ / den_ as a float.

            DIAGONAL OFFSET
                The diag_ parameter determines the diagonal above which elements are masked:
                - diag_ = 0: main diagonal
                - diag_ &gt; 0: diag_ steps above the main diagonal
                - diag_ &lt; 0: |diag_| steps below the main diagonal

            EXAMPLE USAGE
                // Create a layer that masks all elements above the main diagonal with -inf
                tril_&lt;0, neg_infinity_tag&gt; layer1;

                // Create a layer that masks all elements above the main diagonal with 0
                tril_&lt;0, zero_tag&gt; layer2;

                // Create a layer that masks all elements above the main diagonal with 0.5
                tril_&lt;0, void, 1, 2&gt; layer3;

                // Create a layer that masks all elements 5 positions above the main diagonal with -inf
                tril_&lt;5, neg_infinity_tag&gt; layer4;

                // Create a layer that masks all elements 3 positions below the main diagonal with 0.25
                tril_&lt;-3, void, 1, 4&gt; layer5;

            SERIALIZATION SUPPORT
                This object supports serialization and deserialization via the serialize() and deserialize() functions.
        !*/</font>

    <font color='#0000FF'>public</font>:
        <b><a name='tril_'></a>tril_</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font color='#0000FF'>default</font>;
        <font color='#009900'>/*!
            ensures
                - This object is properly initialized.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='setup'></a>setup</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET is a valid network layer type.
            ensures
                - Initializes the mask based on the dimensions of the input tensor from sub.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='forward'></a>forward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> SUBNET<font color='#5555FF'>&amp;</font> sub, resizable_tensor<font color='#5555FF'>&amp;</font> output<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET is a valid network layer type.
            ensures
                - Applies the lower triangular mask to the input tensor from sub and stores the result in output.
        !*/</font>

        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='backward'></a>backward</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> gradient_input, SUBNET<font color='#5555FF'>&amp;</font> sub, tensor<font color='#5555FF'>&amp;</font> params_grad<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SUBNET is a valid network layer type.
            ensures
                - Computes the gradient of the loss with respect to the input tensor and stores it in sub.
        !*/</font>

        <font color='#0000FF'>inline</font> dpoint <b><a name='map_input_to_output'></a>map_input_to_output</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> dpoint<font color='#5555FF'>&amp;</font> p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Maps a point from the input tensor to the corresponding point in the output tensor.
        !*/</font>

        <font color='#0000FF'>inline</font> dpoint <b><a name='map_output_to_input'></a>map_output_to_input</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> dpoint<font color='#5555FF'>&amp;</font> p<font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Maps a point from the output tensor to the corresponding point in the input tensor.
        !*/</font>

        <font color='#0000FF'>const</font> tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font> <font color='#0000FF'>const</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the parameters of this layer.
        !*/</font>

        tensor<font color='#5555FF'>&amp;</font> <b><a name='get_layer_params'></a>get_layer_params</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Returns the parameters of this layer.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='serialize'></a>serialize</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tril_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Serializes the state of this object to the given output stream.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='deserialize'></a>deserialize</b><font face='Lucida Console'>(</font>tril_<font color='#5555FF'>&amp;</font> item, std::istream<font color='#5555FF'>&amp;</font> in<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Deserializes the state of this object from the given input stream.
        !*/</font>

        <font color='#0000FF'>friend</font> std::ostream<font color='#5555FF'>&amp;</font> <b><a name='operator'></a>operator</b><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font>std::ostream<font color='#5555FF'>&amp;</font> out, <font color='#0000FF'>const</font> tril_<font color='#5555FF'>&amp;</font> item<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Prints a human-readable representation of this object to the given output stream.
        !*/</font>

        <font color='#0000FF'>friend</font> <font color='#0000FF'><u>void</u></font> <b><a name='to_xml'></a>to_xml</b><font face='Lucida Console'>(</font><font color='#0000FF'>const</font> tril_<font color='#5555FF'>&amp;</font> item, std::ostream<font color='#5555FF'>&amp;</font> out<font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            ensures
                - Serializes the state of this object to XML format and writes it to the given output stream.
        !*/</font>
    <b>}</b>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> tril <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>tril_<font color='#5555FF'>&lt;</font><font color='#979000'>0</font>, zero_tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> tril_mask <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>tril_<font color='#5555FF'>&lt;</font><font color='#979000'>0</font>, neg_infinity_tag<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'><u>long</u></font> diag, <font color='#0000FF'><u>long</u></font> num, <font color='#0000FF'><u>long</u></font> den, <font color='#0000FF'>typename</font> SUBNET<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>using</font> tril_diag <font color='#5555FF'>=</font> add_layer<font color='#5555FF'>&lt;</font>tril_<font color='#5555FF'>&lt;</font>diag, <font color='#0000FF'><u>void</u></font>, num, den<font color='#5555FF'>&gt;</font>, SUBNET<font color='#5555FF'>&gt;</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<b>}</b>

<font color='#0000FF'>#endif</font> <font color='#009900'>// DLIB_DNn_LAYERS_ABSTRACT_H_
</font>

</pre></body></html>