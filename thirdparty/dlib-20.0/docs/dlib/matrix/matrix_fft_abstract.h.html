<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - matrix_fft_abstract.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>// Copyright (C) 2013  Davis E. King (davis@dlib.net)
</font><font color='#009900'>// License: Boost Software License   See LICENSE.txt for the full license.
</font><font color='#0000FF'>#undef</font> DLIB_FFt_ABSTRACT_Hh_
<font color='#0000FF'>#ifdef</font> DLIB_FFt_ABSTRACT_Hh_

<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='matrix_abstract.h.html'>matrix_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../algs.h.html'>../algs.h</a>"

<font color='#0000FF'>namespace</font> dlib
<b>{</b>
    
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>    
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> EXP::matrix_type <b><a name='fft'></a>fft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;  
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - Computes the 1 or 2 dimensional discrete Fourier transform of the given data
              matrix and returns it.  In particular, we return a matrix D such that:
                - D.nr() == data.nr()
                - D.nc() == data.nc()
                - D(0,0) == the DC term of the Fourier transform.
                - starting with D(0,0), D contains progressively higher frequency components
                  of the input data.
                - ifft(D) == data
    !*/</font>
    
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>    
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font> <font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> Alloc <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>std::complex<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='fft'></a>fft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>std::complex<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>, Alloc<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - Computes the 1 dimensional discrete Fourier transform of the given data
              vector and returns it.  In particular, we return a matrix D such that:
                - D.nr() == data.size()
                - D.nc() == 1
                - D(0,0) == the DC term of the Fourier transform.
                - starting with D(0,0), D contains progressively higher frequency components
                  of the input data.
                - ifft(D) == data
    !*/</font>
    
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> EXP::matrix_type <b><a name='ifft'></a>ifft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;  
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - Computes the 1 or 2 dimensional inverse discrete Fourier transform of the
              given data vector and returns it.  In particular, we return a matrix D such
              that:
                - D.nr() == data.nr()
                - D.nc() == data.nc()
                - fft(D) == data 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>    
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font> <font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> Alloc <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>std::complex<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='ifft'></a>ifft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>std::complex<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>, Alloc<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - Computes the 1 dimensional inverse discrete Fourier transform of the
              given data vector and returns it.  In particular, we return a matrix D such
              that:
                - D.nr() == data.size()
                - D.nc() == 1
                - fft(D) == data 
    !*/</font>
    
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>        
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>add_complex_t<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP::type<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b><a name='fftr'></a>fftr</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;  
    <font color='#009900'>/*!
        requires
            - data contains elements of type double, float, or long double.
            - data.nc() is even
        ensures
            - Computes the 1 or 2 dimensional real discrete Fourier transform of the given data
              matrix and returns it.  In particular, we return a matrix D such that:
                - D.nr() == data.nr()
                - D.nc() == fftr_nc_size(data.nc())
                - D(0,0) == the DC term of the Fourier transform.
                - starting with D(0,0), D contains progressively higher frequency components
                  of the input data.
                - ifftr(D) == data
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>remove_complex_t<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP::type<font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <b><a name='ifftr'></a>ifftr</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;  
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - Computes the 1 or 2 dimensional inverse real discrete Fourier transform of the
              given data vector and returns it.  In particular, we return a matrix D such
              that:
                - D.nr() == data.nr()
                - D.nc() == ifftr_nc_size(data.nc())
                - fftr(D) == data
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>    
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font> 
        <font color='#0000FF'>typename</font> T, 
        <font color='#0000FF'><u>long</u></font> NR,
        <font color='#0000FF'><u>long</u></font> NC,
        <font color='#0000FF'>typename</font> MM,
        <font color='#0000FF'>typename</font> L 
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='fft_inplace'></a>fft_inplace</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>std::complex<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - This function is identical to fft() except that it does the FFT in-place.
              That is, after this function executes we will have:
                - #data == fft(data)
    !*/</font>
    
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font> 
        <font color='#0000FF'>typename</font> T, 
        <font color='#0000FF'><u>long</u></font> NR,
        <font color='#0000FF'><u>long</u></font> NC,
        <font color='#0000FF'>typename</font> MM,
        <font color='#0000FF'>typename</font> L 
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='ifft_inplace'></a>ifft_inplace</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>std::complex<font color='#5555FF'>&lt;</font>T<font color='#5555FF'>&gt;</font>,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> data
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - data contains elements of type std::complex&lt;&gt; that itself contains double, float, or long double.
        ensures
            - This function is identical to ifft() except that it does the inverse FFT
              in-place.  That is, after this function executes we will have:
                - #data == ifft(data)*data.size()
                - Note that the output needs to be divided by data.size() to complete the 
                  inverse transformation.  
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#009900'>// These return function objects with signature double(size_t i, size_t wlen)
</font>    <font color='#009900'>// defining PERIODIC window functions suitable for passing to STFT functions
</font>
    <font color='#0000FF'>inline</font> function_object <b><a name='make_hann'></a>make_hann</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>inline</font> function_object <b><a name='make_blackman'></a>make_blackman</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>inline</font> function_object <b><a name='make_blackman_nuttall'></a>make_blackman_nuttall</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>inline</font> function_object <b><a name='make_blackman_harris'></a>make_blackman_harris</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>inline</font> function_object <b><a name='make_blackman_harris7'></a>make_blackman_harris7</b><font face='Lucida Console'>(</font><font face='Lucida Console'>)</font>;
    <font color='#0000FF'>inline</font> function_object <b><a name='make_kaiser'></a>make_kaiser</b><font face='Lucida Console'>(</font>beta_t beta<font face='Lucida Console'>)</font>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP, <font color='#0000FF'>typename</font> WINDOW<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>complex_type<font color='#5555FF'>&gt;</font> <b><a name='stft'></a>stft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> signal,
        <font color='#0000FF'>const</font> WINDOW<font color='#5555FF'>&amp;</font> w,
        std::<font color='#0000FF'><u>size_t</u></font> fftsize,
        std::<font color='#0000FF'><u>size_t</u></font> wlen,
        std::<font color='#0000FF'><u>size_t</u></font> hoplen
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(signal) == true, i.e. signal has rank 1
            - signal.size() &gt;= wlen
            - w is a function object with signature double(size_t i, size_t wlen) that defines a PERIODIC window,
              e.g. the output of make_hann().
            - fftsize &gt;= wlen
            - wlen &gt;= hoplen
            - EXP::type is a floating point type (float, double or long double), real or complex
        ensures
            - Performs a Short-Time-Fourier-Transform (STFT) on 1D data.
            - Returns a matrix D where first dimension correponds to time and second dimension corresponds to frequency.
            - Dimensions of D are:
                - D.nr() == (signal.size() + hoplen) / hoplen and corresponds to the number of time frames.
                - D.nc() == fftsize
            - The type of D is add_complex_t&lt;EXP::type&gt;
            - Each time frame t (equivalently, each row t) is centered on signal(t*hoplen)
            - This is equivalent to calling the following in python
              (provided w is converted into a string representation which scipy can interpret)
                win     = scipy.signal.get_window(w, wlen)
                scale   = win.sum()
                _, _, Z = scipy.signal.stft(signal, nfft=fftsize, nperseg=wlen, noverlap=(wlen-hoplen), window=win, return_onesided=False)
                Z       *= scale

    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> Alloc, <font color='#0000FF'>typename</font> WINDOW<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>complex_type<font color='#5555FF'>&gt;</font> <b><a name='stft'></a>stft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>T, Alloc<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> signal,
        <font color='#0000FF'>const</font> WINDOW<font color='#5555FF'>&amp;</font> w,
        std::<font color='#0000FF'><u>size_t</u></font> fftsize,
        std::<font color='#0000FF'><u>size_t</u></font> wlen,
        std::<font color='#0000FF'><u>size_t</u></font> hoplen
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - This is a shortcut to calling stft(dlib::mat(signal), w, fftsize, wlen, hoplen)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP,<font color='#0000FF'>typename</font> WINDOW<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>complex_type<font color='#5555FF'>&gt;</font> <b><a name='istft'></a>istft</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> stft,
        <font color='#0000FF'>const</font> WINDOW<font color='#5555FF'>&amp;</font> w,
        std::<font color='#0000FF'><u>size_t</u></font> wlen,
        std::<font color='#0000FF'><u>size_t</u></font> hoplen
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m has rank 2 where 1st dimension corresponds to time and second dimension corresponds to frequency
            - w is a function object with signature double(size_t i, size_t wlen) that defines a PERIODIC window,
              e.g. the output of make_hann().
            - wlen &gt;= hoplen
            - EXP::type is a complex floating point type (complex&lt;float&gt;, complex&lt;double&gt; or complex&lt;long double&gt;)
            - If you wish to satisfy istft(stft(x, ...), ...) == x then:
                - w is the same as what was used with stft()
                - wlen is the same as what was used with stft()
                - hoplen is the same as what was used with stft()
        ensures
            - Performs an inverse Short-Time-Fourier-Transform (STFT)
            - istft(stft(x, w, wlen, wlen, hoplen), w, wlen, hoplen)) == x
            - istft(stft(x, w, fftsize, wlen, hoplen), w, wlen, hoplen)) == x
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP, <font color='#0000FF'>typename</font> WINDOW<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>complex_type<font color='#5555FF'>&gt;</font> <b><a name='stftr'></a>stftr</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> signal,
        <font color='#0000FF'>const</font> WINDOW<font color='#5555FF'>&amp;</font> w,
        std::<font color='#0000FF'><u>size_t</u></font> fftsize,
        std::<font color='#0000FF'><u>size_t</u></font> wlen,
        std::<font color='#0000FF'><u>size_t</u></font> hoplen
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_vector(signal) == true, i.e. signal has rank 1
            - signal.size() &gt;= wlen
            - w is a function object with signature double(size_t i, size_t wlen) that defines a PERIODIC window,
              e.g. the output of make_hann().
            - fftsize &gt;= wlen
            - wlen &gt;= hoplen
            - EXP::type is a floating point type (float, double or long double) and must be real
        ensures
            - Performs a real Short-Time-Fourier-Transform (STFTr) on 1D data.
            - Returns a matrix D where first dimension correponds to time and second dimension corresponds to frequency.
            - Dimensions of D are:
                - D.nr() == (signal.size() + hoplen) / hoplen and corresponds to the number of time frames.
                - D.nc() == fftsize/2 + 1
            - The type of D is add_complex_t&lt;EXP::type&gt;
            - Each time frame t (equivalently each row t) is centered on signal(t*hoplen)
            - This is equivalent to calling the follwoing in python
              (provided w is converted into a string representation which scipy can interpret)
                win     = scipy.signal.get_window(w, wlen)
                scale   = win.sum()
                _, _, Z = scipy.signal.stft(signal, nfft=fftsize, nperseg=wlen, noverlap=(wlen-hoplen), window=win, return_onesided=True)
                Z       *= scale

    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> Alloc, <font color='#0000FF'>typename</font> WINDOW<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>complex_type<font color='#5555FF'>&gt;</font> <b><a name='stftr'></a>stftr</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>T, Alloc<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> signal,
        <font color='#0000FF'>const</font> WINDOW<font color='#5555FF'>&amp;</font> w,
        std::<font color='#0000FF'><u>size_t</u></font> fftsize,
        std::<font color='#0000FF'><u>size_t</u></font> wlen,
        std::<font color='#0000FF'><u>size_t</u></font> hoplen
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        ensures
            - This is a shortcut to calling istft(dlib::mat(signal), w, wlen, hoplen)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP, <font color='#0000FF'>typename</font> WINDOW<font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font>real_type<font color='#5555FF'>&gt;</font> <b><a name='istftr'></a>istftr</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> stft,
        <font color='#0000FF'>const</font> WINDOW<font color='#5555FF'>&amp;</font> w,
        std::<font color='#0000FF'><u>size_t</u></font> wlen,
        std::<font color='#0000FF'><u>size_t</u></font> hoplen
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - m has rank 2 where 1st dimension corresponds to time and second dimension corresponds to frequency
            - w is a function object with signature double(size_t i, size_t wlen) that defines a PERIODIC window,
              e.g. the output of make_hann().
            - wlen &gt;= hoplen
            - EXP::type is a complex floating point type (complex&lt;float&gt;, complex&lt;double&gt; or complex&lt;long double&gt;)
            - If you wish to satisfy istftr(stftr(x, ...), ...) == x then:
                - w is the same as what was used with stftr()
                - wlen is the same as what was used with stftr()
                - hoplen is the same as what was used with stftr()
        ensures
            - Performs an inverse Short-Time-Fourier-Transform (STFT)
            - istftr(stftr(x, w, wlen, wlen, hoplen), w, wlen, hoplen)) == x
            - istftr(stftr(x, w, fftsize, wlen, hoplen), w, wlen, hoplen)) == x
    !*/</font>
<font color='#009900'>// ----------------------------------------------------------------------------------------
</font><b>}</b>

<font color='#0000FF'>#endif</font> <font color='#009900'>// DLIB_FFt_ABSTRACT_Hh_
</font>

</pre></body></html>